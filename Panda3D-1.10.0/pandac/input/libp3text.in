1494874502
3 2
9 libp3text 4 z_GL 12 panda3d.core 
416
435 13 get_character 0 4 851 24 TextGlyph::get_character 0 1 1 96
/**
 * Returns the Unicode value that corresponds to the character this glyph
 * represents.
 */
48
inline int TextGlyph::get_character(void) const;

436 8 has_quad 0 4 851 19 TextGlyph::has_quad 0 1 2 239
/**
 * Returns true if this glyph contains the definition for a simple quad,
 * rather than a more complex piece of geometry.
 *
 * You may still call get_geom() even if this returns true, which will
 * synthesize a Geom for this quad.
 */
44
inline bool TextGlyph::has_quad(void) const;

437 8 get_quad 0 4 851 19 TextGlyph::get_quad 0 1 3 255
/**
 * Assuming that this glyph is representable as a textured quad, returns its
 * dimensions and UV range.  Returns false if it is not representable as a
 * quad, or if it is whitespace.
 *
 * The order of the components is left, bottom, right, top.
 */
83
inline bool TextGlyph::get_quad(LVecBase4 &dimensions, LVecBase4 &texcoords) const;

438 9 get_state 0 4 851 20 TextGlyph::get_state 0 1 4 67
/**
 * Returns the state in which the glyph should be rendered.
 */
59
inline RenderState const *TextGlyph::get_state(void) const;

439 11 get_advance 0 4 851 22 TextGlyph::get_advance 0 1 5 181
/**
 * Returns the distance by which the character pointer should be advanced
 * after placing this character; i.e.  the approximate width the character
 * takes up on the line.
 */
54
inline PN_stdfloat TextGlyph::get_advance(void) const;

440 13 is_whitespace 0 6 851 24 TextGlyph::is_whitespace 0 1 6 127
/**
 * Returns true if this glyph represents invisible whitespace, or false if it
 * corresponds to some visible character.
 */
50
virtual bool TextGlyph::is_whitespace(void) const;

441 8 get_geom 0 4 851 19 TextGlyph::get_geom 0 1 7 195
/**
 * Returns a Geom that renders the particular glyph.  It will be generated if
 * necessary.
 *
 * This method will always return a copy of the Geom, so the caller is free to
 * modify it.
 */
77
PointerTo< Geom > TextGlyph::get_geom(GeomEnums::UsageHint usage_hint) const;

442 14 get_class_type 0 4 851 25 TextGlyph::get_class_type 0 1 8 0
50
static TypeHandle TextGlyph::get_class_type(void);

443 29 upcast_to_TypedReferenceCount 0 12 859 39 TextFont::upcast_to_TypedReferenceCount 0 1 20 43
upcast from TextFont to TypedReferenceCount
67
TypedReferenceCount *TextFont::upcast_to_TypedReferenceCount(void);

444 20 downcast_to_TextFont 0 12 852 41 TypedReferenceCount::downcast_to_TextFont 0 1 21 45
downcast from TypedReferenceCount to TextFont
58
TextFont *TypedReferenceCount::downcast_to_TextFont(void);

445 17 upcast_to_Namable 0 12 859 27 TextFont::upcast_to_Namable 0 1 22 31
upcast from TextFont to Namable
43
Namable *TextFont::upcast_to_Namable(void);

446 20 downcast_to_TextFont 0 12 860 29 Namable::downcast_to_TextFont 0 1 23 33
downcast from Namable to TextFont
46
TextFont *Namable::downcast_to_TextFont(void);

447 9 ~TextFont 0 6 859 19 TextFont::~TextFont 0 0 10
/**
 *
 */
34
virtual TextFont::~TextFont(void);

448 9 make_copy 0 6 859 19 TextFont::make_copy 0 1 9 0
66
virtual PointerTo< TextFont > TextFont::make_copy(void) const = 0;

449 8 is_valid 0 4 859 18 TextFont::is_valid 0 1 10 79
/**
 * Returns true if the font is valid and ready to use, false otherwise.
 */
43
inline bool TextFont::is_valid(void) const;

450 22 operator typecast bool 0 132 859 32 TextFont::operator typecast bool 0 1 19 0
57
inline bool TextFont::operator typecast bool(void) const;

451 15 get_line_height 0 4 859 25 TextFont::get_line_height 0 1 11 65
/**
 * Returns the number of units high each line of text is.
 */
57
inline PN_stdfloat TextFont::get_line_height(void) const;

452 15 set_line_height 0 4 859 25 TextFont::set_line_height 0 1 12 65
/**
 * Changes the number of units high each line of text is.
 */
63
inline void TextFont::set_line_height(PN_stdfloat line_height);

453 17 get_space_advance 0 4 859 27 TextFont::get_space_advance 0 1 13 55
/**
 * Returns the number of units wide a space is.
 */
59
inline PN_stdfloat TextFont::get_space_advance(void) const;

454 17 set_space_advance 0 4 859 27 TextFont::set_space_advance 0 1 14 55
/**
 * Changes the number of units wide a space is.
 */
67
inline void TextFont::set_space_advance(PN_stdfloat space_advance);

455 9 get_glyph 0 4 859 19 TextFont::get_glyph 0 1 15 294
/**
 * Gets the glyph associated with the given character code, as well as an
 * optional scaling parameter that should be applied to the glyph's geometry
 * and advance parameters.  Returns the glyph on success.  On failure, it may
 * still return a printable glyph, or it may return NULL.
 */
70
inline ConstPointerTo< TextGlyph > TextFont::get_glyph(int character);

456 11 get_kerning 0 6 859 21 TextFont::get_kerning 0 1 16 180
/**
 * Returns the amount by which to offset the second glyph when it directly
 * follows the first glyph.  This is an additional offset that is added on top
 * of the advance.
 */
71
virtual PN_stdfloat TextFont::get_kerning(int first, int second) const;

457 5 write 0 6 859 15 TextFont::write 0 1 17 10
/**
 *
 */
67
virtual void TextFont::write(ostream &out, int indent_level) const;

458 14 get_class_type 0 4 859 24 TextFont::get_class_type 0 1 18 0
49
static TypeHandle TextFont::get_class_type(void);

459 8 get_page 0 4 863 26 DynamicTextGlyph::get_page 0 1 24 61
/**
 * Returns the DynamicTextPage that this glyph is on.
 */
63
inline DynamicTextPage *DynamicTextGlyph::get_page(void) const;

460 8 get_size 0 4 865 25 DynamicTextPage::get_size 0 1 36 61
/**
 * Returns the size of the page (texture), in pixels.
 */
63
inline LVecBase2i const &DynamicTextPage::get_size(void) const;

461 10 get_x_size 0 4 865 27 DynamicTextPage::get_x_size 0 1 37 63
/**
 * Returns the x size of the page (texture), in pixels.
 */
51
inline int DynamicTextPage::get_x_size(void) const;

462 10 get_y_size 0 4 865 27 DynamicTextPage::get_y_size 0 1 38 63
/**
 * Returns the y size of the page (texture), in pixels.
 */
51
inline int DynamicTextPage::get_y_size(void) const;

463 8 is_empty 0 4 865 25 DynamicTextPage::is_empty 0 1 39 67
/**
 * Returns true if the page has no glyphs, false otherwise.
 */
50
inline bool DynamicTextPage::is_empty(void) const;

464 14 get_class_type 0 4 865 31 DynamicTextPage::get_class_type 0 1 40 0
56
static TypeHandle DynamicTextPage::get_class_type(void);

465 15 DynamicTextPage 0 4 865 32 DynamicTextPage::DynamicTextPage 0 1 35 10
/**
 *
 */
75
inline DynamicTextPage::DynamicTextPage(DynamicTextPage const &) = default;

466 16 ~DynamicTextPage 0 4 865 33 DynamicTextPage::~DynamicTextPage 0 0 0
40
DynamicTextPage::~DynamicTextPage(void);

467 10 intersects 0 4 863 28 DynamicTextGlyph::intersects 0 1 25 207
/**
 * Returns true if the particular position this glyph has been assigned to
 * overlaps the rectangle whose top left corner is at x, y and whose size is
 * given by x_size, y_size, or false otherwise.
 */
85
inline bool DynamicTextGlyph::intersects(int x, int y, int x_size, int y_size) const;

468 8 get_left 0 4 863 26 DynamicTextGlyph::get_left 0 1 26 99
/**
 * Returns the vertex coordinates that can be used when creating a custom text
 * renderer.
 */
58
inline PN_stdfloat DynamicTextGlyph::get_left(void) const;

469 10 get_bottom 0 4 863 28 DynamicTextGlyph::get_bottom 0 1 27 99
/**
 * Returns the vertex coordinates that can be used when creating a custom text
 * renderer.
 */
60
inline PN_stdfloat DynamicTextGlyph::get_bottom(void) const;

470 9 get_right 0 4 863 27 DynamicTextGlyph::get_right 0 1 28 99
/**
 * Returns the vertex coordinates that can be used when creating a custom text
 * renderer.
 */
59
inline PN_stdfloat DynamicTextGlyph::get_right(void) const;

471 7 get_top 0 4 863 25 DynamicTextGlyph::get_top 0 1 29 99
/**
 * Returns the vertex coordinates that can be used when creating a custom text
 * renderer.
 */
57
inline PN_stdfloat DynamicTextGlyph::get_top(void) const;

472 11 get_uv_left 0 4 863 29 DynamicTextGlyph::get_uv_left 0 1 30 95
/**
 * Returns the UV coordinates that can be used when creating a custom text
 * renderer.
 */
61
inline PN_stdfloat DynamicTextGlyph::get_uv_left(void) const;

473 13 get_uv_bottom 0 4 863 31 DynamicTextGlyph::get_uv_bottom 0 1 31 95
/**
 * Returns the UV coordinates that can be used when creating a custom text
 * renderer.
 */
63
inline PN_stdfloat DynamicTextGlyph::get_uv_bottom(void) const;

474 12 get_uv_right 0 4 863 30 DynamicTextGlyph::get_uv_right 0 1 32 95
/**
 * Returns the UV coordinates that can be used when creating a custom text
 * renderer.
 */
62
inline PN_stdfloat DynamicTextGlyph::get_uv_right(void) const;

475 10 get_uv_top 0 4 863 28 DynamicTextGlyph::get_uv_top 0 1 33 95
/**
 * Returns the UV coordinates that can be used when creating a custom text
 * renderer.
 */
60
inline PN_stdfloat DynamicTextGlyph::get_uv_top(void) const;

476 14 get_class_type 0 4 863 32 DynamicTextGlyph::get_class_type 0 1 34 0
57
static TypeHandle DynamicTextGlyph::get_class_type(void);

477 18 upcast_to_TextFont 0 12 867 35 DynamicTextFont::upcast_to_TextFont 0 1 89 39
upcast from DynamicTextFont to TextFont
52
TextFont *DynamicTextFont::upcast_to_TextFont(void);

478 27 downcast_to_DynamicTextFont 0 12 859 37 TextFont::downcast_to_DynamicTextFont 0 1 90 41
downcast from TextFont to DynamicTextFont
61
DynamicTextFont *TextFont::downcast_to_DynamicTextFont(void);

479 22 upcast_to_FreetypeFont 0 12 867 39 DynamicTextFont::upcast_to_FreetypeFont 0 1 91 43
upcast from DynamicTextFont to FreetypeFont
60
FreetypeFont *DynamicTextFont::upcast_to_FreetypeFont(void);

480 27 downcast_to_DynamicTextFont 0 12 868 41 FreetypeFont::downcast_to_DynamicTextFont 0 1 92 45
downcast from FreetypeFont to DynamicTextFont
65
DynamicTextFont *FreetypeFont::downcast_to_DynamicTextFont(void);

481 15 DynamicTextFont 0 4 867 32 DynamicTextFont::DynamicTextFont 0 3 41 42 43 324
/**
 * The constructor expects the name of some font file that FreeType can read,
 * along with face_index, indicating which font within the file to load
 * (usually 0).
 */

/**
 * This constructor accepts a table of data representing the font file, loaded
 * from some source other than a filename on disk.
 */

/**
 *
 */
237
DynamicTextFont::DynamicTextFont(Filename const &font_filename, int face_index = 0);
DynamicTextFont::DynamicTextFont(char const *font_data, int data_length, int face_index);
DynamicTextFont::DynamicTextFont(DynamicTextFont const &copy);

482 16 ~DynamicTextFont 0 6 867 33 DynamicTextFont::~DynamicTextFont 0 0 10
/**
 *
 */
48
virtual DynamicTextFont::~DynamicTextFont(void);

483 9 make_copy 0 6 867 26 DynamicTextFont::make_copy 0 1 44 47
/**
 * Returns a new copy of the same font.
 */
69
virtual PointerTo< TextFont > DynamicTextFont::make_copy(void) const;

484 8 get_name 0 4 867 25 DynamicTextFont::get_name 0 1 45 124
/**
 * Disambiguates the get_name() method between that inherited from TextFont
 * and that inherited from FreetypeFont.
 */
64
inline std::string const &DynamicTextFont::get_name(void) const;

485 14 set_point_size 0 4 867 31 DynamicTextFont::set_point_size 0 1 46 295
/**
 * Sets the point size of the font.  This controls the apparent size of the
 * font onscreen.  By convention, a 10 point font is about 1 screen unit high.
 *
 * This should only be called before any characters have been requested out of
 * the font, or immediately after calling clear().
 */
68
inline bool DynamicTextFont::set_point_size(PN_stdfloat point_size);

486 14 get_point_size 0 4 867 31 DynamicTextFont::get_point_size 0 1 47 46
/**
 * Returns the point size of the font.
 */
63
inline PN_stdfloat DynamicTextFont::get_point_size(void) const;

487 19 set_pixels_per_unit 0 4 867 36 DynamicTextFont::set_pixels_per_unit 0 1 48 433
/**
 * Set the resolution of the texture map, and hence the clarity of the
 * resulting font.  This sets the number of pixels in the texture map that are
 * used for each onscreen unit.
 *
 * Setting this number larger results in an easier to read font, but at the
 * cost of more texture memory.
 *
 * This should only be called before any characters have been requested out of
 * the font, or immediately after calling clear().
 */
78
inline bool DynamicTextFont::set_pixels_per_unit(PN_stdfloat pixels_per_unit);

488 19 get_pixels_per_unit 0 4 867 36 DynamicTextFont::get_pixels_per_unit 0 1 49 81
/**
 * Returns the resolution of the texture map.  See set_pixels_per_unit().
 */
68
inline PN_stdfloat DynamicTextFont::get_pixels_per_unit(void) const;

489 16 set_scale_factor 0 4 867 33 DynamicTextFont::set_scale_factor 0 1 50 591
/**
 * Sets the factor by which the font is rendered larger by the FreeType
 * library before being filtered down to its actual size in the texture as
 * specified by set_pixels_per_unit().  This may be set to a number larger
 * than 1.0 to improve the font's antialiasing (since FreeType doesn't really
 * do a swell job of antialiasing by itself).  There is some performance
 * implication for setting this different than 1.0, but it is probably small.
 *
 * This should only be called before any characters have been requested out of
 * the font, or immediately after calling clear().
 */
72
inline bool DynamicTextFont::set_scale_factor(PN_stdfloat scale_factor);

490 16 get_scale_factor 0 4 867 33 DynamicTextFont::get_scale_factor 0 1 51 74
/**
 * Returns the antialiasing scale factor.  See set_scale_factor().
 */
65
inline PN_stdfloat DynamicTextFont::get_scale_factor(void) const;

491 20 set_native_antialias 0 4 867 37 DynamicTextFont::set_native_antialias 0 1 52 469
/**
 * Sets whether the Freetype library's built-in antialias mode is enabled.
 * There are two unrelated ways to achieve antialiasing: with Freetype's
 * native antialias mode, and with the use of a scale_factor greater than one.
 * By default, both modes are enabled.
 *
 * At low resolutions, some fonts may do better with one mode or the other.
 * In general, Freetype's native antialiasing will produce less blurry
 * results, but may introduce more artifacts.
 */
73
inline void DynamicTextFont::set_native_antialias(bool native_antialias);

492 20 get_native_antialias 0 4 867 37 DynamicTextFont::get_native_antialias 0 1 53 105
/**
 * Returns whether Freetype's built-in antialias mode is enabled.  See
 * set_native_antialias().
 */
62
inline bool DynamicTextFont::get_native_antialias(void) const;

493 19 get_font_pixel_size 0 4 867 36 DynamicTextFont::get_font_pixel_size 0 1 54 386
/**
 * This is used to report whether the requested pixel size is being only
 * approximated by a fixed-pixel-size font.  This returns 0 in the normal
 * case, in which a scalable font is used, or the fixed-pixel-size font has
 * exactly the requested pixel size.
 *
 * If this returns non-zero, it is the pixel size of the font that we are
 * using to approximate our desired size.
 */
60
inline int DynamicTextFont::get_font_pixel_size(void) const;

494 15 get_line_height 0 4 867 32 DynamicTextFont::get_line_height 0 1 55 65
/**
 * Returns the number of units high each line of text is.
 */
64
inline PN_stdfloat DynamicTextFont::get_line_height(void) const;

495 17 get_space_advance 0 4 867 34 DynamicTextFont::get_space_advance 0 1 56 55
/**
 * Returns the number of units wide a space is.
 */
66
inline PN_stdfloat DynamicTextFont::get_space_advance(void) const;

496 18 set_texture_margin 0 4 867 35 DynamicTextFont::set_texture_margin 0 1 57 207
/**
 * Sets the number of pixels of padding that is added around the border of
 * each glyph before adding it to the texture map.  This reduces the bleed in
 * from neighboring glyphs in the texture map.
 */
68
inline void DynamicTextFont::set_texture_margin(int texture_margin);

497 18 get_texture_margin 0 4 867 35 DynamicTextFont::get_texture_margin 0 1 58 146
/**
 * Returns the number of pixels of padding that is added around the border of
 * each glyph in the texture map.  See set_texture_margin().
 */
59
inline int DynamicTextFont::get_texture_margin(void) const;

498 15 set_poly_margin 0 4 867 32 DynamicTextFont::set_poly_margin 0 1 59 452
/**
 * Sets the number of pixels of padding that is included around each glyph in
 * the generated polygons.  This helps prevent the edges of the glyphs from
 * being cut off at small minifications.  It is not related to the amount of
 * extra pixels reserved in the texture map (but it should be set somewhat
 * smaller than this number, which is controlled by set_texture_margin(), to
 * prevent bleed-in from neighboring letters in the texture).
 */
70
inline void DynamicTextFont::set_poly_margin(PN_stdfloat poly_margin);

499 15 get_poly_margin 0 4 867 32 DynamicTextFont::get_poly_margin 0 1 60 139
/**
 * Returns the number of pixels of padding that is included around each glyph
 * in the generated polygons.  See set_poly_margin().
 */
64
inline PN_stdfloat DynamicTextFont::get_poly_margin(void) const;

500 13 set_page_size 0 4 867 30 DynamicTextFont::set_page_size 0 2 61 62 182
/**
 * Sets the x, y size of the textures that are created for the
 * DynamicTextFont.
 */

/**
 * Sets the x, y size of the textures that are created for the
 * DynamicTextFont.
 */
140
inline void DynamicTextFont::set_page_size(LVecBase2i const &page_size);
inline void DynamicTextFont::set_page_size(int x_size, int y_size);

501 13 get_page_size 0 4 867 30 DynamicTextFont::get_page_size 0 1 63 109
/**
 * Returns the size of the textures that are created for the DynamicTextFont.
 * See set_page_size().
 */
68
inline LVecBase2i const &DynamicTextFont::get_page_size(void) const;

502 15 get_page_x_size 0 4 867 32 DynamicTextFont::get_page_x_size 0 1 64 112
/**
 * Returns the x size of the textures that are created for the
 * DynamicTextFont.  See set_page_size().
 */
56
inline int DynamicTextFont::get_page_x_size(void) const;

503 15 get_page_y_size 0 4 867 32 DynamicTextFont::get_page_y_size 0 1 65 112
/**
 * Returns the y size of the textures that are created for the
 * DynamicTextFont.  See set_page_size().
 */
56
inline int DynamicTextFont::get_page_y_size(void) const;

504 13 set_minfilter 0 4 867 30 DynamicTextFont::set_minfilter 0 1 66 91
/**
 * Sets the filter type used when minimizing the textures created for this
 * font.
 */
76
inline void DynamicTextFont::set_minfilter(SamplerState::FilterType filter);

505 13 get_minfilter 0 4 867 30 DynamicTextFont::get_minfilter 0 1 67 94
/**
 * Returns the filter type used when minimizing the textures created for this
 * font.
 */
75
inline SamplerState::FilterType DynamicTextFont::get_minfilter(void) const;

506 13 set_magfilter 0 4 867 30 DynamicTextFont::set_magfilter 0 1 68 90
/**
 * Sets the filter type used when enlarging the textures created for this
 * font.
 */
76
inline void DynamicTextFont::set_magfilter(SamplerState::FilterType filter);

507 13 get_magfilter 0 4 867 30 DynamicTextFont::get_magfilter 0 1 69 93
/**
 * Returns the filter type used when enlarging the textures created for this
 * font.
 */
75
inline SamplerState::FilterType DynamicTextFont::get_magfilter(void) const;

508 22 set_anisotropic_degree 0 4 867 39 DynamicTextFont::set_anisotropic_degree 0 1 70 210
/**
 * Enables or disables anisotropic filtering on the textures created for this
 * font.  The default value is specified by the text-anisotropic-degree
 * variable.  See Texture::set_anisotropic_degree().
 */
76
inline void DynamicTextFont::set_anisotropic_degree(int anisotropic_degree);

509 22 get_anisotropic_degree 0 4 867 39 DynamicTextFont::get_anisotropic_degree 0 1 71 118
/**
 * Returns the current anisotropic degree for textures created for this font.
 * See set_anisotropic_degree().
 */
63
inline int DynamicTextFont::get_anisotropic_degree(void) const;

510 15 set_render_mode 0 4 867 32 DynamicTextFont::set_render_mode 0 1 72 211
/**
 * Specifies the way the glyphs on this particular font are generated.  The
 * default is RM_texture, which is the only mode supported for bitmap fonts.
 * Other modes are possible for most modern fonts.
 */
79
inline void DynamicTextFont::set_render_mode(TextFont::RenderMode render_mode);

511 15 get_render_mode 0 4 867 32 DynamicTextFont::get_render_mode 0 1 73 103
/**
 * Returns the way the glyphs on this particular font are generated.  See
 * set_render_mode().
 */
73
inline TextFont::RenderMode DynamicTextFont::get_render_mode(void) const;

512 6 set_fg 0 4 867 23 DynamicTextFont::set_fg 0 1 74 485
/**
 * Changes the color of the foreground pixels of the font as they are rendered
 * into the font texture.  The default is (1, 1, 1, 1), or opaque white, which
 * allows text created with the font to be colored individually.  Normally,
 * you would not change this unless you really need a particular color effect
 * to appear in the font itself.
 *
 * This should only be called before any characters have been requested out of
 * the font, or immediately after calling clear().
 */
54
inline void DynamicTextFont::set_fg(LColor const &fg);

513 6 get_fg 0 4 867 23 DynamicTextFont::get_fg 0 1 75 127
/**
 * Returns the color of the foreground pixels of the font as they are rendered
 * into the font texture.  See set_fg().
 */
57
inline LColor const &DynamicTextFont::get_fg(void) const;

514 6 set_bg 0 4 867 23 DynamicTextFont::set_bg 0 1 76 673
/**
 * Changes the color of the background pixels of the font as they are rendered
 * into the font texture.  The default is (1, 1, 1, 0), or transparent white,
 * which allows text created with the font to be colored individually.  (Note
 * that it should not generally be (0, 0, 0, 0), which would tend to bleed
 * into the foreground color, unless you have also specified a outline color
 * of (0, 0, 0, 1)) .
 *
 * Normally, you would not change this unless you really need a particular
 * color effect to appear in the font itself.
 *
 * This should only be called before any characters have been requested out of
 * the font, or immediately after calling clear().
 */
54
inline void DynamicTextFont::set_bg(LColor const &bg);

515 6 get_bg 0 4 867 23 DynamicTextFont::get_bg 0 1 77 127
/**
 * Returns the color of the background pixels of the font as they are rendered
 * into the font texture.  See set_bg().
 */
57
inline LColor const &DynamicTextFont::get_bg(void) const;

516 11 set_outline 0 4 867 28 DynamicTextFont::set_outline 0 1 78 722
/**
 * Sets up the font to have an outline around each font letter.  This is
 * achieved via a Gaussian post-process as each letter is generated; there is
 * some runtime cost for this effect, but it is minimal as each letter is
 * normally generated only once and then cached.
 *
 * The color is the desired color of the outline, width is the number of
 * points beyond the letter that the outline extends (a typical font is 10
 * points high), and feather is a number in the range 0.0 .. 1.0 that controls
 * the softness of the outline.  Set the width to 0.0 to disable the outline.
 *
 * This should only be called before any characters have been requested out of
 * the font, or immediately after calling clear().
 */
126
inline void DynamicTextFont::set_outline(LColor const &outline_color, PN_stdfloat outline_width, PN_stdfloat outline_feather);

517 17 get_outline_color 0 4 867 34 DynamicTextFont::get_outline_color 0 1 79 129
/**
 * Returns the color of the outline pixels of the font as they are rendered
 * into the font texture.  See set_outline().
 */
68
inline LColor const &DynamicTextFont::get_outline_color(void) const;

518 17 get_outline_width 0 4 867 34 DynamicTextFont::get_outline_width 0 1 80 130
/**
 * Returns the width of the outline pixels of the font, as the number of
 * points beyond each letter.  See set_outline().
 */
66
inline PN_stdfloat DynamicTextFont::get_outline_width(void) const;

519 19 get_outline_feather 0 4 867 36 DynamicTextFont::get_outline_feather 0 1 81 124
/**
 * Returns the softness of the outline pixels of the font, as a value in the
 * range 0.0 to 1.0. See set_outline().
 */
68
inline PN_stdfloat DynamicTextFont::get_outline_feather(void) const;

520 14 get_tex_format 0 4 867 31 DynamicTextFont::get_tex_format 0 1 82 138
/**
 * Returns the texture format used to render the individual pages.  This is
 * set automatically according to the colors selected.
 */
67
inline Texture::Format DynamicTextFont::get_tex_format(void) const;

521 13 get_num_pages 0 4 867 30 DynamicTextFont::get_num_pages 0 1 83 313
/**
 * Returns the number of pages associated with the font.  Initially, the font
 * has zero pages; when the first piece of text is rendered with the font, it
 * will add additional pages as needed.  Each page is a Texture object that
 * contains the images for each of the glyphs currently in use somewhere.
 */
47
int DynamicTextFont::get_num_pages(void) const;

522 8 get_page 0 4 867 25 DynamicTextFont::get_page 0 1 84 306
/**
 * Returns the nth page associated with the font.  Initially, the font has
 * zero pages; when the first piece of text is rendered with the font, it will
 * add additional pages as needed.  Each page is a Texture object that
 * contains the images for each of the glyphs currently in use somewhere.
 */
56
DynamicTextPage *DynamicTextFont::get_page(int n) const;

523 15 garbage_collect 0 4 867 32 DynamicTextFont::garbage_collect 0 1 85 136
/**
 * Removes all of the glyphs from the font that are no longer being used by
 * any Geoms.  Returns the number of glyphs removed.
 */
43
int DynamicTextFont::garbage_collect(void);

524 5 clear 0 4 867 22 DynamicTextFont::clear 0 1 86 385
/**
 * Drops all the glyphs out of the cache and frees any association with any
 * previously-generated pages.
 *
 * Calling this frequently can result in wasted texture memory, as any
 * previously rendered text will still keep a pointer to the old, previously-
 * generated pages.  As long as the previously rendered text remains around,
 * the old pages will also remain around.
 */
34
void DynamicTextFont::clear(void);

525 5 write 0 6 867 22 DynamicTextFont::write 0 1 87 10
/**
 *
 */
74
virtual void DynamicTextFont::write(ostream &out, int indent_level) const;

526 14 get_class_type 0 4 867 31 DynamicTextFont::get_class_type 0 1 88 0
56
static TypeHandle DynamicTextFont::get_class_type(void);

527 8 has_font 0 4 878 18 FontPool::has_font 0 1 93 74
/**
 * Returns true if the font has ever been loaded, false otherwise.
 */
67
static inline bool FontPool::has_font(std::string const &filename);

528 11 verify_font 0 4 878 21 FontPool::verify_font 0 1 94 299
/**
 * Loads the given filename up into a font, if it has not already been loaded,
 * and returns true to indicate success, or false to indicate failure.  If
 * this returns true, it is guaranteed that a subsequent call to load_font()
 * with the same font name will return a valid Font pointer.
 */
70
static inline bool FontPool::verify_font(std::string const &filename);

529 9 load_font 0 4 878 19 FontPool::load_font 0 1 95 253
/**
 * Loads the given filename up into a font, if it has not already been loaded,
 * and returns the new font.  If a font with the same filename was previously
 * loaded, returns that one instead.  If the font file cannot be found,
 * returns NULL.
 */
73
static inline TextFont *FontPool::load_font(std::string const &filename);

530 8 add_font 0 4 878 18 FontPool::add_font 0 1 96 162
/**
 * Adds the indicated already-loaded font to the pool.  The font will always
 * replace any previously-loaded font in the pool that had the same filename.
 */
83
static inline void FontPool::add_font(std::string const &filename, TextFont *font);

531 12 release_font 0 4 878 22 FontPool::release_font 0 1 97 262
/**
 * Removes the indicated font from the pool, indicating it will never be
 * loaded again; the font may then be freed.  If this function is never
 * called, a reference count will be maintained on every font every loaded,
 * and fonts will never be freed.
 */
71
static inline void FontPool::release_font(std::string const &filename);

532 17 release_all_fonts 0 4 878 27 FontPool::release_all_fonts 0 1 98 83
/**
 * Releases all fonts in the pool and restores the pool to the empty state.
 */
53
static inline void FontPool::release_all_fonts(void);

533 15 garbage_collect 0 4 878 25 FontPool::garbage_collect 0 1 99 203
/**
 * Releases only those fonts in the pool that have a reference count of
 * exactly 1; i.e.  only those fonts that are not being used outside of the
 * pool.  Returns the number of fonts released.
 */
50
static inline int FontPool::garbage_collect(void);

534 13 list_contents 0 4 878 23 FontPool::list_contents 0 1 100 78
/**
 * Lists the contents of the font pool to the indicated output stream.
 */
57
static inline void FontPool::list_contents(ostream &out);

535 5 write 0 4 878 15 FontPool::write 0 1 101 78
/**
 * Lists the contents of the font pool to the indicated output stream.
 */
42
static void FontPool::write(ostream &out);

536 9 ~FontPool 0 4 878 19 FontPool::~FontPool 0 0 0
26
FontPool::~FontPool(void);

537 14 get_class_type 0 4 879 29 GeomTextGlyph::get_class_type 0 1 102 0
54
static TypeHandle GeomTextGlyph::get_class_type(void);

538 14 StaticTextFont 0 4 881 30 StaticTextFont::StaticTextFont 0 1 103 374
/**
 * The constructor expects the root node to a model generated via egg-mkfont,
 * which consists of a set of models, one per each character in the font.
 *
 * If a CoordinateSystem value is specified, it informs the font of the
 * coordinate system in which this model was generated.  "up" in this
 * coordinate system will be the direction of the top of the letters.
 */
88
StaticTextFont::StaticTextFont(PandaNode *font_def, CoordinateSystem cs = ::CS_default);

539 14 get_class_type 0 4 881 30 StaticTextFont::get_class_type 0 1 104 0
55
static TypeHandle StaticTextFont::get_class_type(void);

540 15 ~StaticTextFont 0 4 881 31 StaticTextFont::~StaticTextFont 0 0 0
38
StaticTextFont::~StaticTextFont(void);

541 14 TextProperties 0 4 882 30 TextProperties::TextProperties 0 2 105 106 22
/**
 *
 */

/**
 *
 */
97
TextProperties::TextProperties(void);
TextProperties::TextProperties(TextProperties const &copy);

542 10 operator = 0 4 882 26 TextProperties::operator = 0 1 107 0
60
void TextProperties::operator =(TextProperties const &copy);

543 11 operator == 0 4 882 27 TextProperties::operator == 0 1 108 0
68
bool TextProperties::operator ==(TextProperties const &other) const;

544 11 operator != 0 4 882 27 TextProperties::operator != 0 1 109 0
75
inline bool TextProperties::operator !=(TextProperties const &other) const;

545 5 clear 0 4 882 21 TextProperties::clear 0 1 110 136
/**
 * Unsets all properties that have been specified so far, and resets the
 * TextProperties structure to its initial empty state.
 */
33
void TextProperties::clear(void);

546 16 is_any_specified 0 4 882 32 TextProperties::is_any_specified 0 1 111 79
/**
 * Returns true if any properties have been specified, false otherwise.
 */
57
inline bool TextProperties::is_any_specified(void) const;

547 16 set_default_font 0 4 882 32 TextProperties::set_default_font 0 1 112 122
/**
 * Specifies the default font to be used for any TextNode whose font is
 * uninitialized or NULL.  See set_font().
 */
64
static inline void TextProperties::set_default_font(TextFont *);

548 16 get_default_font 0 4 882 32 TextProperties::get_default_font 0 1 113 122
/**
 * Specifies the default font to be used for any TextNode whose font is
 * uninitialized or NULL.  See set_font().
 */
63
static inline TextFont *TextProperties::get_default_font(void);

549 8 set_font 0 4 882 24 TextProperties::set_font 0 1 114 160
/**
 * Sets the font that will be used when making text.  If this is set to NULL,
 * the default font will be used, which can be set via set_default_font().
 */
53
inline void TextProperties::set_font(TextFont *font);

550 10 clear_font 0 4 882 26 TextProperties::clear_font 0 1 115 49
/**
 * Restores the default font to the text.
 */
45
inline void TextProperties::clear_font(void);

551 8 has_font 0 4 882 24 TextProperties::has_font 0 1 116 10
/**
 *
 */
49
inline bool TextProperties::has_font(void) const;

552 8 get_font 0 4 882 24 TextProperties::get_font 0 1 117 110
/**
 * Returns the font currently in use, if any.  If no font is in use, this
 * returns the default font.
 */
54
inline TextFont *TextProperties::get_font(void) const;

553 14 set_small_caps 0 4 882 30 TextProperties::set_small_caps 0 1 118 707
/**
 * Sets the small_caps flag.  When this is set, lowercase letters are
 * generated as scaled-down versions of their uppercase equivalents.  This is
 * particularly useful to set for fonts that do not have lowercase letters.
 *
 * It is also a good idea to set this for a (dynamic) font that has already
 * implemented lowercase letters as scaled-down versions of their uppercase
 * equivalents, since without this flag the texture memory may needlessly
 * duplicate equivalent glyphs for upper and lowercase letters.  Setting this
 * flag causes the texture memory to share the mixed-case letters.
 *
 * The amount by which the lowercase letters are scaled is specified by
 * set_small_caps_scale().
 */
60
inline void TextProperties::set_small_caps(bool small_caps);

554 16 clear_small_caps 0 4 882 32 TextProperties::clear_small_caps 0 1 119 10
/**
 *
 */
51
inline void TextProperties::clear_small_caps(void);

555 14 has_small_caps 0 4 882 30 TextProperties::has_small_caps 0 1 120 10
/**
 *
 */
55
inline bool TextProperties::has_small_caps(void) const;

556 14 get_small_caps 0 4 882 30 TextProperties::get_small_caps 0 1 121 62
/**
 * Returns the small_caps flag.  See set_small_caps().
 */
55
inline bool TextProperties::get_small_caps(void) const;

557 20 set_small_caps_scale 0 4 882 36 TextProperties::set_small_caps_scale 0 1 122 210
/**
 * Sets the scale factor applied to lowercase letters from their uppercase
 * equivalents, when the small_caps flag is in effect.  See set_small_caps().
 * Normally, this will be a number less than one.
 */
79
inline void TextProperties::set_small_caps_scale(PN_stdfloat small_caps_scale);

558 22 clear_small_caps_scale 0 4 882 38 TextProperties::clear_small_caps_scale 0 1 123 10
/**
 *
 */
57
inline void TextProperties::clear_small_caps_scale(void);

559 20 has_small_caps_scale 0 4 882 36 TextProperties::has_small_caps_scale 0 1 124 10
/**
 *
 */
61
inline bool TextProperties::has_small_caps_scale(void) const;

560 20 get_small_caps_scale 0 4 882 36 TextProperties::get_small_caps_scale 0 1 125 193
/**
 * Returns the scale factor applied to lowercase letters from their uppercase
 * equivalents, when the small_caps flag is in effect.  See set_small_caps()
 * and set_small_caps_scale().
 */
68
inline PN_stdfloat TextProperties::get_small_caps_scale(void) const;

561 9 set_slant 0 4 882 25 TextProperties::set_slant 0 1 126 70
/**
 * Specifies the factor by which the text slants to the right.
 */
57
inline void TextProperties::set_slant(PN_stdfloat slant);

562 11 clear_slant 0 4 882 27 TextProperties::clear_slant 0 1 127 10
/**
 *
 */
46
inline void TextProperties::clear_slant(void);

563 9 has_slant 0 4 882 25 TextProperties::has_slant 0 1 128 10
/**
 *
 */
50
inline bool TextProperties::has_slant(void) const;

564 9 get_slant 0 4 882 25 TextProperties::get_slant 0 1 129 83
/**
 * Returns the factor by which the text is specified to slant to the right.
 */
57
inline PN_stdfloat TextProperties::get_slant(void) const;

565 14 set_underscore 0 4 882 30 TextProperties::set_underscore 0 1 130 169
/**
 * Sets the underscore flag.  When this is set, the text is underscored with a
 * one-pixel line the same color as the text foreground, drawn at the
 * baseline.
 */
60
inline void TextProperties::set_underscore(bool underscore);

566 16 clear_underscore 0 4 882 32 TextProperties::clear_underscore 0 1 131 10
/**
 *
 */
51
inline void TextProperties::clear_underscore(void);

567 14 has_underscore 0 4 882 30 TextProperties::has_underscore 0 1 132 10
/**
 *
 */
55
inline bool TextProperties::has_underscore(void) const;

568 14 get_underscore 0 4 882 30 TextProperties::get_underscore 0 1 133 62
/**
 * Returns the underscore flag.  See set_underscore().
 */
55
inline bool TextProperties::get_underscore(void) const;

569 21 set_underscore_height 0 4 882 37 TextProperties::set_underscore_height 0 1 134 176
/**
 * Specifies the vertical height of the underscore, relative to the text
 * baseline.  This only has meaning if the underscore mode is enabled with
 * set_underscore().
 */
81
inline void TextProperties::set_underscore_height(PN_stdfloat underscore_height);

570 23 clear_underscore_height 0 4 882 39 TextProperties::clear_underscore_height 0 1 135 10
/**
 *
 */
58
inline void TextProperties::clear_underscore_height(void);

571 21 has_underscore_height 0 4 882 37 TextProperties::has_underscore_height 0 1 136 10
/**
 *
 */
62
inline bool TextProperties::has_underscore_height(void) const;

572 21 get_underscore_height 0 4 882 37 TextProperties::get_underscore_height 0 1 137 86
/**
 * Returns the vertical height of the underscore; see set_underscore_height().
 */
69
inline PN_stdfloat TextProperties::get_underscore_height(void) const;

573 9 set_align 0 4 882 25 TextProperties::set_align 0 1 138 66
/**
 * Specifies the alignment of the text within its margins.
 */
76
inline void TextProperties::set_align(TextProperties::Alignment align_type);

574 11 clear_align 0 4 882 27 TextProperties::clear_align 0 1 139 54
/**
 * Restores the default alignment of the text.
 */
46
inline void TextProperties::clear_align(void);

575 9 has_align 0 4 882 25 TextProperties::has_align 0 1 140 10
/**
 *
 */
50
inline bool TextProperties::has_align(void) const;

576 9 get_align 0 4 882 25 TextProperties::get_align 0 1 141 10
/**
 *
 */
71
inline TextProperties::Alignment TextProperties::get_align(void) const;

577 10 set_indent 0 4 882 26 TextProperties::set_indent 0 1 142 149
/**
 * Specifies the amount of extra space that is inserted before the first
 * character of each line.  This can be thought of as a left margin.
 */
59
inline void TextProperties::set_indent(PN_stdfloat indent);

578 12 clear_indent 0 4 882 28 TextProperties::clear_indent 0 1 143 84
/**
 * Removes the indent setting from the text.  Text will be as wide as it is.
 */
47
inline void TextProperties::clear_indent(void);

579 10 has_indent 0 4 882 26 TextProperties::has_indent 0 1 144 10
/**
 *
 */
51
inline bool TextProperties::has_indent(void) const;

580 10 get_indent 0 4 882 26 TextProperties::get_indent 0 1 145 10
/**
 *
 */
58
inline PN_stdfloat TextProperties::get_indent(void) const;

581 12 set_wordwrap 0 4 882 28 TextProperties::set_wordwrap 0 1 146 152
/**
 * Sets the text up to automatically wordwrap when it exceeds the indicated
 * width.  This can be thought of as a right margin or margin width.
 */
63
inline void TextProperties::set_wordwrap(PN_stdfloat wordwrap);

582 14 clear_wordwrap 0 4 882 30 TextProperties::clear_wordwrap 0 1 147 86
/**
 * Removes the wordwrap setting from the text.  Text will be as wide as it is.
 */
49
inline void TextProperties::clear_wordwrap(void);

583 12 has_wordwrap 0 4 882 28 TextProperties::has_wordwrap 0 1 148 10
/**
 *
 */
53
inline bool TextProperties::has_wordwrap(void) const;

584 12 get_wordwrap 0 4 882 28 TextProperties::get_wordwrap 0 1 149 10
/**
 *
 */
60
inline PN_stdfloat TextProperties::get_wordwrap(void) const;

585 32 set_preserve_trailing_whitespace 0 4 882 48 TextProperties::set_preserve_trailing_whitespace 0 1 150 344
/**
 * Sets the preserve_trailing_whitespace flag.  When this is set, trailing
 * whitespace at the end of the line is not stripped when the text is
 * wordwrapped (it is stripped by default).  Since the trailing whitespace is
 * invisible, this is important primarily for determining the proper width of
 * a frame or card behind the text.
 */
96
inline void TextProperties::set_preserve_trailing_whitespace(bool preserve_trailing_whitespace);

586 34 clear_preserve_trailing_whitespace 0 4 882 50 TextProperties::clear_preserve_trailing_whitespace 0 1 151 10
/**
 *
 */
69
inline void TextProperties::clear_preserve_trailing_whitespace(void);

587 32 has_preserve_trailing_whitespace 0 4 882 48 TextProperties::has_preserve_trailing_whitespace 0 1 152 10
/**
 *
 */
73
inline bool TextProperties::has_preserve_trailing_whitespace(void) const;

588 32 get_preserve_trailing_whitespace 0 4 882 48 TextProperties::get_preserve_trailing_whitespace 0 1 153 101
/**
 * Returns the preserve_trailing_whitespace flag.  See
 * set_preserve_trailing_whitespace().
 */
73
inline bool TextProperties::get_preserve_trailing_whitespace(void) const;

589 14 set_text_color 0 4 882 30 TextProperties::set_text_color 0 2 154 155 22
/**
 *
 */

/**
 *
 */
173
inline void TextProperties::set_text_color(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b, PN_stdfloat a);
inline void TextProperties::set_text_color(LColor const &text_color);

590 16 clear_text_color 0 4 882 32 TextProperties::clear_text_color 0 1 156 117
/**
 * Removes the text color specification; the text will be colored whatever it
 * was in the source font file.
 */
51
inline void TextProperties::clear_text_color(void);

591 14 has_text_color 0 4 882 30 TextProperties::has_text_color 0 1 157 10
/**
 *
 */
55
inline bool TextProperties::has_text_color(void) const;

592 14 get_text_color 0 4 882 30 TextProperties::get_text_color 0 1 158 10
/**
 *
 */
57
inline LColor TextProperties::get_text_color(void) const;

593 16 set_shadow_color 0 4 882 32 TextProperties::set_shadow_color 0 2 159 160 22
/**
 *
 */

/**
 *
 */
179
inline void TextProperties::set_shadow_color(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b, PN_stdfloat a);
inline void TextProperties::set_shadow_color(LColor const &shadow_color);

594 18 clear_shadow_color 0 4 882 34 TextProperties::clear_shadow_color 0 1 161 50
/**
 * Removes the shadow color specification.
 */
53
inline void TextProperties::clear_shadow_color(void);

595 16 has_shadow_color 0 4 882 32 TextProperties::has_shadow_color 0 1 162 10
/**
 *
 */
57
inline bool TextProperties::has_shadow_color(void) const;

596 16 get_shadow_color 0 4 882 32 TextProperties::get_shadow_color 0 1 163 10
/**
 *
 */
59
inline LColor TextProperties::get_shadow_color(void) const;

597 10 set_shadow 0 4 882 26 TextProperties::set_shadow 0 2 164 165 304
/**
 * Specifies that the text should be drawn with a shadow, by creating a second
 * copy of the text and offsetting it slightly behind the first.
 */

/**
 * Specifies that the text should be drawn with a shadow, by creating a second
 * copy of the text and offsetting it slightly behind the first.
 */
153
inline void TextProperties::set_shadow(PN_stdfloat xoffset, PN_stdfloat yoffset);
inline void TextProperties::set_shadow(LVecBase2 const &shadow_offset);

598 12 clear_shadow 0 4 882 28 TextProperties::clear_shadow 0 1 166 69
/**
 * Specifies that a shadow will not be drawn behind the text.
 */
47
inline void TextProperties::clear_shadow(void);

599 10 has_shadow 0 4 882 26 TextProperties::has_shadow 0 1 167 10
/**
 *
 */
51
inline bool TextProperties::has_shadow(void) const;

600 10 get_shadow 0 4 882 26 TextProperties::get_shadow 0 1 168 125
/**
 * Returns the offset of the shadow as set by set_shadow().  It is an error to
 * call this if has_shadow() is false.
 */
55
inline LVector2 TextProperties::get_shadow(void) const;

601 7 set_bin 0 4 882 23 TextProperties::set_bin 0 1 169 350
/**
 * Names the CullBin that the text geometry should be assigned to.  If this is
 * set, then a CullBinAttrib will be created to explicitly place each
 * component in the named bin.
 *
 * The draw_order value will also be passed to each CullBinAttrib as
 * appropriate; this is particularly useful if this names a CullBinFixed, e.g.
 * "fixed".
 */
60
inline void TextProperties::set_bin(std::string const &bin);

602 9 clear_bin 0 4 882 25 TextProperties::clear_bin 0 1 170 158
/**
 * Removes the effect of a previous call to set_bin().  Text will be drawn in
 * whatever bin it would like to be drawn in, with no explicit ordering.
 */
44
inline void TextProperties::clear_bin(void);

603 7 has_bin 0 4 882 23 TextProperties::has_bin 0 1 171 98
/**
 * Returns true if an explicit drawing bin has been set via set_bin(), false
 * otherwise.
 */
48
inline bool TextProperties::has_bin(void) const;

604 7 get_bin 0 4 882 23 TextProperties::get_bin 0 1 172 97
/**
 * Returns the drawing bin set with set_bin(), or empty string if no bin has
 * been set.
 */
62
inline std::string const &TextProperties::get_bin(void) const;

605 14 set_draw_order 0 4 882 30 TextProperties::set_draw_order 0 1 173 435
/**
 * Sets the drawing order of text created by the TextNode.  This is actually
 * the draw order of the card and frame.  The shadow is drawn at
 * _draw_order+1, and the text at _draw_order+2.
 *
 * This affects the sorting order assigned to the nodes as they are created,
 * and also is passed to whatever bin may be assigned via set_bin().
 *
 * The return value is the first unused draw_order number, e.g.  _draw_order +
 * 3.
 */
58
inline int TextProperties::set_draw_order(int draw_order);

606 16 clear_draw_order 0 4 882 32 TextProperties::clear_draw_order 0 1 174 10
/**
 *
 */
51
inline void TextProperties::clear_draw_order(void);

607 14 has_draw_order 0 4 882 30 TextProperties::has_draw_order 0 1 175 10
/**
 *
 */
55
inline bool TextProperties::has_draw_order(void) const;

608 14 get_draw_order 0 4 882 30 TextProperties::get_draw_order 0 1 176 63
/**
 * Returns the drawing order set with set_draw_order().
 */
54
inline int TextProperties::get_draw_order(void) const;

609 13 set_tab_width 0 4 882 29 TextProperties::set_tab_width 0 1 177 160
/**
 * Sets the width of each tab stop, in screen units.  A tab character embedded
 * in the text will advance the horizontal position to the next tab stop.
 */
65
inline void TextProperties::set_tab_width(PN_stdfloat tab_width);

610 15 clear_tab_width 0 4 882 31 TextProperties::clear_tab_width 0 1 178 10
/**
 *
 */
50
inline void TextProperties::clear_tab_width(void);

611 13 has_tab_width 0 4 882 29 TextProperties::has_tab_width 0 1 179 10
/**
 *
 */
54
inline bool TextProperties::has_tab_width(void) const;

612 13 get_tab_width 0 4 882 29 TextProperties::get_tab_width 0 1 180 53
/**
 * Returns the width set via set_tab_width().
 */
61
inline PN_stdfloat TextProperties::get_tab_width(void) const;

613 15 set_glyph_scale 0 4 882 31 TextProperties::set_glyph_scale 0 1 181 576
/**
 * Specifies the factor by which to scale each letter of the text as it is
 * placed, in addition to any scales inherited from the node or from
 * set_text_scale(). This can be used (possibly in conjunction with
 * set_glyph_shift()) to implement superscripting or subscripting.
 *
 * The glyph scale is cumulative when applied to nested TextProperties.  It is
 * intended primarily for implementing superscripts, not for scaling the text
 * in general.  See also set_text_scale(), which is intended primarily for
 * scaling the text in general, and is not cumulative.
 */
69
inline void TextProperties::set_glyph_scale(PN_stdfloat glyph_scale);

614 17 clear_glyph_scale 0 4 882 33 TextProperties::clear_glyph_scale 0 1 182 10
/**
 *
 */
52
inline void TextProperties::clear_glyph_scale(void);

615 15 has_glyph_scale 0 4 882 31 TextProperties::has_glyph_scale 0 1 183 10
/**
 *
 */
56
inline bool TextProperties::has_glyph_scale(void) const;

616 15 get_glyph_scale 0 4 882 31 TextProperties::get_glyph_scale 0 1 184 85
/**
 * Returns the scale factor of each letter as specified by set_glyph_scale().
 */
63
inline PN_stdfloat TextProperties::get_glyph_scale(void) const;

617 15 set_glyph_shift 0 4 882 31 TextProperties::set_glyph_shift 0 1 185 206
/**
 * Specifies a vertical amount to shift each letter of the text as it is
 * placed.  This can be used (possibly in conjunction with set_glyph_scale())
 * to implement superscripting or subscripting.
 */
69
inline void TextProperties::set_glyph_shift(PN_stdfloat glyph_shift);

618 17 clear_glyph_shift 0 4 882 33 TextProperties::clear_glyph_shift 0 1 186 10
/**
 *
 */
52
inline void TextProperties::clear_glyph_shift(void);

619 15 has_glyph_shift 0 4 882 31 TextProperties::has_glyph_shift 0 1 187 10
/**
 *
 */
56
inline bool TextProperties::has_glyph_shift(void) const;

620 15 get_glyph_shift 0 4 882 31 TextProperties::get_glyph_shift 0 1 188 90
/**
 * Returns the vertical shift of each letter as specified by
 * set_glyph_shift().
 */
63
inline PN_stdfloat TextProperties::get_glyph_shift(void) const;

621 14 set_text_scale 0 4 882 30 TextProperties::set_text_scale 0 1 189 284
/**
 * Specifies the factor by which to scale the text, in addition to any
 * scalings imposed by the node, as well as in addition to the glyph scale.
 *
 * The text scale is not cumulative when applied to nested TextProperties.
 * See also set_glyph_scale(), which is cumulative.
 */
67
inline void TextProperties::set_text_scale(PN_stdfloat text_scale);

622 16 clear_text_scale 0 4 882 32 TextProperties::clear_text_scale 0 1 190 10
/**
 *
 */
51
inline void TextProperties::clear_text_scale(void);

623 14 has_text_scale 0 4 882 30 TextProperties::has_text_scale 0 1 191 10
/**
 *
 */
55
inline bool TextProperties::has_text_scale(void) const;

624 14 get_text_scale 0 4 882 30 TextProperties::get_text_scale 0 1 192 81
/**
 * Returns the scale factor of the text as specified by set_text_scale().
 */
62
inline PN_stdfloat TextProperties::get_text_scale(void) const;

625 13 set_direction 0 4 882 29 TextProperties::set_direction 0 1 193 122
/**
 * Specifies the text direction.  If none is specified, it will be guessed
 * based on the contents of the string.
 */
79
inline void TextProperties::set_direction(TextProperties::Direction direction);

626 15 clear_direction 0 4 882 31 TextProperties::clear_direction 0 1 194 140
/**
 * Clears the text direction setting.  If no text direction is specified, it
 * will be guessed based on the contents of the string.
 */
50
inline void TextProperties::clear_direction(void);

627 13 has_direction 0 4 882 29 TextProperties::has_direction 0 1 195 10
/**
 *
 */
54
inline bool TextProperties::has_direction(void) const;

628 13 get_direction 0 4 882 29 TextProperties::get_direction 0 1 196 77
/**
 * Returns the direction of the text as specified by set_direction().
 */
75
inline TextProperties::Direction TextProperties::get_direction(void) const;

629 14 add_properties 0 4 882 30 TextProperties::add_properties 0 1 197 123
/**
 * Sets any properties that are explicitly specified in other on this object.
 * Leaves other properties unchanged.
 */
65
void TextProperties::add_properties(TextProperties const &other);

630 5 write 0 4 882 21 TextProperties::write 0 1 198 10
/**
 *
 */
69
void TextProperties::write(ostream &out, int indent_level = 0) const;

631 14 get_class_type 0 4 882 30 TextProperties::get_class_type 0 1 199 0
55
static TypeHandle TextProperties::get_class_type(void);

632 15 ~TextProperties 0 4 882 31 TextProperties::~TextProperties 0 0 0
38
TextProperties::~TextProperties(void);

633 11 TextGraphic 0 4 891 24 TextGraphic::TextGraphic 0 4 200 201 202 203 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
312
inline TextGraphic::TextGraphic(void);
inline TextGraphic::TextGraphic(NodePath const &model, LVecBase4 const &frame);
inline TextGraphic::TextGraphic(NodePath const &model, PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top);
inline TextGraphic::TextGraphic(TextGraphic const &) = default;

634 9 get_model 0 4 891 22 TextGraphic::get_model 0 1 204 95
/**
 * Returns the NodePath associated with the graphic, that renders the desired
 * image.
 */
51
inline NodePath TextGraphic::get_model(void) const;

635 9 set_model 0 4 891 22 TextGraphic::set_model 0 1 205 146
/**
 * Changes the NodePath associated with the graphic.  This NodePath should
 * contain geometry that will render the desired graphic image.
 */
58
inline void TextGraphic::set_model(NodePath const &model);

636 9 get_frame 0 4 891 22 TextGraphic::get_frame 0 1 206 457
/**
 * Returns the frame specified for the graphic.  This is the amount of space
 * that will be reserved for the graphic when it is embedded in a text
 * paragraph, in the form (left, right, bottom, top).
 *
 * The actual graphic, as rendered by the NodePath specified via set_model(),
 * should more or less fit within this rectangle.  It is not required to fit
 * completely within it, but if it does not, it may visually overlap with
 * nearby text.
 */
52
inline LVecBase4 TextGraphic::get_frame(void) const;

637 9 set_frame 0 4 891 22 TextGraphic::set_frame 0 2 207 208 208
/**
 * Specifies the (left, right, bottom, top) bounding frame for the graphic.
 * See get_frame().
 */

/**
 * Specifies the (left, right, bottom, top) bounding frame for the graphic.
 * See get_frame().
 */
169
inline void TextGraphic::set_frame(LVecBase4 const &frame);
inline void TextGraphic::set_frame(PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top);

638 17 get_instance_flag 0 4 891 30 TextGraphic::get_instance_flag 0 1 209 63
/**
 * Returns the instance_flag.  See set_instance_flag().
 */
55
inline bool TextGraphic::get_instance_flag(void) const;

639 17 set_instance_flag 0 4 891 30 TextGraphic::set_instance_flag 0 1 210 355
/**
 * Sets the instance_flag.  When this is true, the graphic is directly
 * instanced to the scene graph whenever it appears; when it is false, the
 * graphic is copied.  The default is false, which is best for most
 * applications.  You might need to set it true for special kinds of
 * "graphics" like interactive elements, for instance a PGEntry.
 */
63
inline void TextGraphic::set_instance_flag(bool instance_flag);

640 12 ~TextGraphic 0 4 891 25 TextGraphic::~TextGraphic 0 0 0
32
TextGraphic::~TextGraphic(void);

641 14 set_properties 0 4 894 37 TextPropertiesManager::set_properties 0 1 211 377
/**
 * Defines the TextProperties associated with the indicated name.  When the
 * name is subsequently encountered in text embedded between \1 characters in
 * a TextNode string, the following text will be rendered with these
 * properties.
 *
 * If there was already a TextProperties structure associated with this name,
 * it is quietly replaced with the new definition.
 */
102
void TextPropertiesManager::set_properties(std::string const &name, TextProperties const &properties);

642 14 get_properties 0 4 894 37 TextPropertiesManager::get_properties 0 1 212 355
/**
 * Returns the TextProperties associated with the indicated name.  If there
 * was not previously a TextProperties associated with this name, a warning is
 * printed and then a default TextProperties structure is associated with the
 * name, and returned.
 *
 * Call has_properties() instead to check whether a particular name has been
 * defined.
 */
78
TextProperties TextPropertiesManager::get_properties(std::string const &name);

643 14 has_properties 0 4 894 37 TextPropertiesManager::has_properties 0 1 213 372
/**
 * Returns true if a TextProperties structure has been associated with the
 * indicated name, false otherwise.  Normally this means set_properties() has
 * been called with this name, but because get_properties() will implicitly
 * create a default TextProperties structure, it may also mean simply that
 * get_properties() has been called with the indicated name.
 */
74
bool TextPropertiesManager::has_properties(std::string const &name) const;

644 16 clear_properties 0 4 894 39 TextPropertiesManager::clear_properties 0 1 214 71
/**
 * Removes the named TextProperties structure from the manager.
 */
70
void TextPropertiesManager::clear_properties(std::string const &name);

645 11 set_graphic 0 4 894 34 TextPropertiesManager::set_graphic 0 2 215 216 651
/**
 * Defines the TextGraphic associated with the indicated name.  When the name
 * is subsequently encountered in text embedded between \5 characters in a
 * TextNode string, the specified graphic will be embedded in the text at that
 * point.
 *
 * If there was already a TextGraphic structure associated with this name, it
 * is quietly replaced with the new definition.
 */

/**
 * This flavor of set_graphic implicitly creates a frame for the model using
 * the model's actual computed bounding volume, as derived from
 * NodePath::calc_tight_bounds().  Create a TextGraphic object first if you
 * want to have explicit control of the frame.
 */
182
void TextPropertiesManager::set_graphic(std::string const &name, TextGraphic const &graphic);
void TextPropertiesManager::set_graphic(std::string const &name, NodePath const &model);

646 11 get_graphic 0 4 894 34 TextPropertiesManager::get_graphic 0 1 217 343
/**
 * Returns the TextGraphic associated with the indicated name.  If there was
 * not previously a TextGraphic associated with this name, a warning is
 * printed and then a default TextGraphic structure is associated with the
 * name, and returned.
 *
 * Call has_graphic() instead to check whether a particular name has been
 * defined.
 */
72
TextGraphic TextPropertiesManager::get_graphic(std::string const &name);

647 11 has_graphic 0 4 894 34 TextPropertiesManager::has_graphic 0 1 218 357
/**
 * Returns true if a TextGraphic structure has been associated with the
 * indicated name, false otherwise.  Normally this means set_graphic() has
 * been called with this name, but because get_graphic() will implicitly
 * create a default TextGraphic structure, it may also mean simply that
 * get_graphic() has been called with the indicated name.
 */
71
bool TextPropertiesManager::has_graphic(std::string const &name) const;

648 13 clear_graphic 0 4 894 36 TextPropertiesManager::clear_graphic 0 1 219 68
/**
 * Removes the named TextGraphic structure from the manager.
 */
67
void TextPropertiesManager::clear_graphic(std::string const &name);

649 5 write 0 4 894 28 TextPropertiesManager::write 0 1 220 10
/**
 *
 */
76
void TextPropertiesManager::write(ostream &out, int indent_level = 0) const;

650 14 get_global_ptr 0 4 894 37 TextPropertiesManager::get_global_ptr 0 1 221 74
/**
 * Returns the pointer to the global TextPropertiesManager object.
 */
74
static TextPropertiesManager *TextPropertiesManager::get_global_ptr(void);

651 13 TextAssembler 0 4 895 28 TextAssembler::TextAssembler 0 2 222 223 22
/**
 *
 */

/**
 *
 */
108
TextAssembler::TextAssembler(TextEncoder *encoder);
TextAssembler::TextAssembler(TextAssembler const &copy);

652 10 operator = 0 4 895 25 TextAssembler::operator = 0 1 224 0
58
void TextAssembler::operator =(TextAssembler const &copy);

653 14 ~TextAssembler 0 4 895 29 TextAssembler::~TextAssembler 0 0 10
/**
 *
 */
36
TextAssembler::~TextAssembler(void);

654 5 clear 0 4 895 20 TextAssembler::clear 0 1 225 59
/**
 * Reinitializes the contents of the TextAssembler.
 */
32
void TextAssembler::clear(void);

655 14 set_usage_hint 0 4 895 29 TextAssembler::set_usage_hint 0 1 226 278
/**
 * Specifies the UsageHint that will be applied to generated geometry.  The
 * default is UH_static, which is probably the right setting, but if you know
 * the TextNode's geometry will have a short lifespan, it may be better to set
 * it to UH_stream.  See geomEnums.h.
 */
75
inline void TextAssembler::set_usage_hint(GeomEnums::UsageHint usage_hint);

656 14 get_usage_hint 0 4 895 29 TextAssembler::get_usage_hint 0 1 227 102
/**
 * Returns the UsageHint that will be applied to generated geometry.  See
 * set_usage_hint().
 */
70
inline GeomEnums::UsageHint TextAssembler::get_usage_hint(void) const;

657 12 set_max_rows 0 4 895 27 TextAssembler::set_max_rows 0 1 228 264
/**
 * If max_rows is greater than zero, no more than max_rows will be accepted.
 * Text beyond that will be truncated.
 *
 * Setting this will not truncate text immediately.  You must follow this up
 * with a call to set_wtext() to truncate the existing text.
 */
54
inline void TextAssembler::set_max_rows(int max_rows);

658 12 get_max_rows 0 4 895 27 TextAssembler::get_max_rows 0 1 229 123
/**
 * If max_rows is greater than zero, no more than max_rows will be accepted.
 * Text beyond that will be truncated.
 */
51
inline int TextAssembler::get_max_rows(void) const;

659 17 set_dynamic_merge 0 4 895 32 TextAssembler::set_dynamic_merge 0 1 230 75
/**
 * Sets the dynamic_merge flag.  See TextNode::set_flatten_flags().
 */
65
inline void TextAssembler::set_dynamic_merge(bool dynamic_merge);

660 17 get_dynamic_merge 0 4 895 32 TextAssembler::get_dynamic_merge 0 1 231 78
/**
 * Returns the dynamic_merge flag.  See TextNode::set_flatten_flags().
 */
57
inline bool TextAssembler::get_dynamic_merge(void) const;

661 18 set_multiline_mode 0 4 895 33 TextAssembler::set_multiline_mode 0 1 232 112
/**
 * Sets the multiline mode flag.  Set the multiline mode to allow text to
 * wrap.  It defaults to true.
 */
57
inline void TextAssembler::set_multiline_mode(bool flag);

662 18 get_multiline_mode 0 4 895 33 TextAssembler::get_multiline_mode 0 1 233 79
/**
 * Returns the multline_mode flag.  See TextNode::set_multiline_mode().
 */
58
inline bool TextAssembler::get_multiline_mode(void) const;

663 14 set_properties 0 4 895 29 TextAssembler::set_properties 0 1 234 135
/**
 * Specifies the default TextProperties that are applied to the text in the
 * absence of any nested property change sequences.
 */
76
inline void TextAssembler::set_properties(TextProperties const &properties);

664 14 get_properties 0 4 895 29 TextAssembler::get_properties 0 3 235 236 237 372
/**
 * Returns the default TextProperties that are applied to the text in the
 * absence of any nested property change sequences.
 */

/**
 * Returns the TextProperties in effect for the object at the indicated
 * position in the pre-wordwrapped string.
 */

/**
 * Returns the TextProperties in effect for the object at the indicated
 * position in the indicated row.
 */
224
inline TextProperties const &TextAssembler::get_properties(void) const;
inline TextProperties const &TextAssembler::get_properties(int n) const;
inline TextProperties const &TextAssembler::get_properties(int r, int c) const;

665 9 set_wtext 0 4 895 24 TextAssembler::set_wtext 0 1 238 326
/**
 * Accepts a new text string and associated properties structure, and
 * precomputes the wordwrapping layout appropriately.  After this call,
 * get_wordwrapped_wtext() and get_num_rows() can be called.
 *
 * The return value is true if all the text is accepted, or false if some was
 * truncated (see set_max_rows()).
 */
57
bool TextAssembler::set_wtext(std::wstring const &wtext);

666 11 set_wsubstr 0 4 895 26 TextAssembler::set_wsubstr 0 1 239 595
/**
 * Replaces the 'count' characters from 'start' of the current text with the
 * indicated replacement text.  If the replacement text does not have count
 * characters, the length of the string will be changed accordingly.
 *
 * The substring may include nested formatting characters, but they must be
 * self-contained and self-closed.  The formatting characters are not
 * literally saved in the internal string; they are parsed at the time of the
 * set_wsubstr() call.
 *
 * The return value is true if all the text is accepted, or false if some was
 * truncated (see set_max_rows()).
 */
81
bool TextAssembler::set_wsubstr(std::wstring const &wtext, int start, int count);

667 15 get_plain_wtext 0 4 895 30 TextAssembler::get_plain_wtext 0 1 240 379
/**
 * Returns a wstring that represents the contents of the text, without any
 * embedded properties characters.  If there is an embedded graphic object, a
 * zero value is inserted in that position.
 *
 * This string has the same length as get_num_characters(), and the characters
 * in this string correspond one-to-one with the characters returned by
 * get_character(n).
 */
56
std::wstring TextAssembler::get_plain_wtext(void) const;

668 27 get_wordwrapped_plain_wtext 0 4 895 42 TextAssembler::get_wordwrapped_plain_wtext 0 1 241 471
/**
 * Returns a wstring that represents the contents of the text, with newlines
 * inserted according to the wordwrapping.  The string will contain no
 * embedded properties characters.  If there is an embedded graphic object, a
 * zero value is inserted in that position.
 *
 * This string has the same number of newline characters as get_num_rows(),
 * and the characters in this string correspond one-to-one with the characters
 * returned by get_character(r, c).
 */
68
std::wstring TextAssembler::get_wordwrapped_plain_wtext(void) const;

669 9 get_wtext 0 4 895 24 TextAssembler::get_wtext 0 1 242 258
/**
 * Returns a wstring that represents the contents of the text.
 *
 * The string will contain embedded properties characters, which may not
 * exactly match the embedded properties characters of the original string,
 * but it will encode the same way.
 */
50
std::wstring TextAssembler::get_wtext(void) const;

670 21 get_wordwrapped_wtext 0 4 895 36 TextAssembler::get_wordwrapped_wtext 0 1 243 598
/**
 * Returns a wstring that represents the contents of the text, with newlines
 * inserted according to the wordwrapping.
 *
 * The string will contain embedded properties characters, which may not
 * exactly match the embedded properties characters of the original string,
 * but it will encode the same way.
 *
 * Embedded properties characters will be closed before every newline, then
 * reopened (if necessary) on the subsequent character following the newline.
 * This means it will be safe to divide the text up at the newline characters
 * and treat each line as an independent piece.
 */
62
std::wstring TextAssembler::get_wordwrapped_wtext(void) const;

671 8 calc_r_c 0 4 895 23 TextAssembler::calc_r_c 0 0 399
/**
 * Computes the row and column index of the nth character or graphic object in
 * the text.  Fills r and c accordingly.
 *
 * Returns true if the nth character is valid and has a corresponding r and c
 * position, false otherwise (for instance, a soft-hyphen character, or a
 * newline character, may not have a corresponding position). In either case,
 * r and c will be filled in sensibly.
 */
58
bool TextAssembler::calc_r_c(int &r, int &c, int n) const;

672 6 calc_r 0 4 895 21 TextAssembler::calc_r 0 1 244 330
/**
 * Computes the row index of the nth character or graphic object in the text
 * and returns it.
 *
 * If the nth character is not a normal printable character with a position in
 * the wordwrapped string, returns -1 (for instance, a soft-hyphen character,
 * or a newline character, may not have a corresponding position).
 */
46
inline int TextAssembler::calc_r(int n) const;

673 6 calc_c 0 4 895 21 TextAssembler::calc_c 0 1 245 333
/**
 * Computes the column index of the nth character or graphic object in the
 * text and returns it.
 *
 * If the nth character is not a normal printable character with a position in
 * the wordwrapped string, returns -1 (for instance, a soft-hyphen character,
 * or a newline character, may not have a corresponding position).
 */
46
inline int TextAssembler::calc_c(int n) const;

674 10 calc_index 0 4 895 25 TextAssembler::calc_index 0 1 246 299
/**
 * Computes the character index of the character at the rth row and cth column
 * position.  This is the inverse of calc_r_c().
 *
 * It is legal for c to exceed the index number of the last column by 1, and
 * it is legal for r to exceed the index number of the last row by 1, if c is
 * 0.
 */
50
int TextAssembler::calc_index(int r, int c) const;

675 18 get_num_characters 0 4 895 33 TextAssembler::get_num_characters 0 1 247 73
/**
 * Returns the number of characters of text, before wordwrapping.
 */
57
inline int TextAssembler::get_num_characters(void) const;

676 13 get_character 0 4 895 28 TextAssembler::get_character 0 2 248 249 357
/**
 * Returns the character at the indicated position in the pre-wordwrapped
 * string.  If the object at this position is a graphic object instead of a
 * character, returns 0.
 */

/**
 * Returns the character at the indicated position in the indicated row.  If
 * the object at this position is a graphic object instead of a character,
 * returns 0.
 */
122
inline wchar_t TextAssembler::get_character(int n) const;
inline wchar_t TextAssembler::get_character(int r, int c) const;

677 11 get_graphic 0 4 895 26 TextAssembler::get_graphic 0 2 250 251 372
/**
 * Returns the graphic object at the indicated position in the pre-wordwrapped
 * string.  If the object at this position is a character instead of a graphic
 * object, returns NULL.
 */

/**
 * Returns the graphic object at the indicated position in the indicated row.
 * If the object at this position is a character instead of a graphic object,
 * returns NULL.
 */
140
inline TextGraphic const *TextAssembler::get_graphic(int n) const;
inline TextGraphic const *TextAssembler::get_graphic(int r, int c) const;

678 9 get_width 0 4 895 24 TextAssembler::get_width 0 2 252 253 223
/**
 * Returns the width of the character or object at the indicated position in
 * the pre-wordwrapped string.
 */

/**
 * Returns the width of the character or object at the indicated position in
 * the indicated row.
 */
122
inline PN_stdfloat TextAssembler::get_width(int n) const;
inline PN_stdfloat TextAssembler::get_width(int r, int c) const;

679 12 get_num_rows 0 4 895 27 TextAssembler::get_num_rows 0 1 254 97
/**
 * Returns the number of rows of text after it has all been wordwrapped and
 * assembled.
 */
51
inline int TextAssembler::get_num_rows(void) const;

680 12 get_num_cols 0 4 895 27 TextAssembler::get_num_cols 0 1 255 82
/**
 * Returns the number of characters and/or graphic objects in the nth row.
 */
52
inline int TextAssembler::get_num_cols(int r) const;

681 8 get_xpos 0 4 895 23 TextAssembler::get_xpos 0 1 256 297
/**
 * Returns the x position of the origin of the character or graphic object at
 * the indicated position in the indicated row.
 *
 * It is legal for c to exceed the index number of the last column by 1, and
 * it is legal for r to exceed the index number of the last row by 1, if c is
 * 0.
 */
56
PN_stdfloat TextAssembler::get_xpos(int r, int c) const;

682 8 get_ypos 0 4 895 23 TextAssembler::get_ypos 0 1 257 230
/**
 * Returns the y position of the origin of all of the characters or graphic
 * objects in the indicated row.
 *
 * It is legal for r to exceed the index number of the last row by 1.  The
 * value of c is presently ignored.
 */
63
inline PN_stdfloat TextAssembler::get_ypos(int r, int c) const;

683 13 assemble_text 0 4 895 28 TextAssembler::assemble_text 0 1 258 247
/**
 * Actually assembles all of the text into a GeomNode, and returns the node
 * (or possibly a parent of the node, to keep the shadow separate).  Once this
 * has been called, you may query the extents of the text via get_ul(),
 * get_lr().
 */
58
PointerTo< PandaNode > TextAssembler::assemble_text(void);

684 6 get_ul 0 4 895 21 TextAssembler::get_ul 0 1 259 91
/**
 * Returns the upper-left corner of the assembled text, in 2-d text
 * coordinates.
 */
57
inline LVector2 const &TextAssembler::get_ul(void) const;

685 6 get_lr 0 4 895 21 TextAssembler::get_lr 0 1 260 92
/**
 * Returns the lower-right corner of the assembled text, in 2-d text
 * coordinates.
 */
57
inline LVector2 const &TextAssembler::get_lr(void) const;

686 10 calc_width 0 4 895 25 TextAssembler::calc_width 0 2 261 262 422
/**
 * Returns the width of a single character, according to its associated font.
 */

/**
 * Returns the width of a single character, according to its associated font.
 * This also correctly calculates the width of cheesy ligatures and accented
 * characters, which may not exist in the font as such.
 *
 * This does not take kerning into account, however.
 */

/**
 * Returns the width of a single TextGraphic image.
 */
206
static PN_stdfloat TextAssembler::calc_width(wchar_t character, TextProperties const &properties);
static PN_stdfloat TextAssembler::calc_width(TextGraphic const *graphic, TextProperties const &properties);

687 19 has_exact_character 0 4 895 34 TextAssembler::has_exact_character 0 1 263 634
/**
 * Returns true if the named character exists in the font exactly as named,
 * false otherwise.  Note that because Panda can assemble glyphs together
 * automatically using cheesy accent marks, this is not a reliable indicator
 * of whether a suitable glyph can be rendered for the character.  For that,
 * use has_character() instead.
 *
 * This returns true for whitespace and Unicode whitespace characters (if they
 * exist in the font), but returns false for characters that would render with
 * the "invalid glyph".  It also returns false for characters that would be
 * synthesized within Panda, but see has_character().
 */
100
static bool TextAssembler::has_exact_character(wchar_t character, TextProperties const &properties);

688 13 has_character 0 4 895 28 TextAssembler::has_character 0 1 264 405
/**
 * Returns true if the named character exists in the font or can be
 * synthesized by Panda, false otherwise.  (Panda can synthesize some accented
 * characters by combining similar-looking glyphs from the font.)
 *
 * This returns true for whitespace and Unicode whitespace characters (if they
 * exist in the font), but returns false for characters that would render with
 * the "invalid glyph".
 */
94
static bool TextAssembler::has_character(wchar_t character, TextProperties const &properties);

689 13 is_whitespace 0 4 895 28 TextAssembler::is_whitespace 0 1 265 695
/**
 * Returns true if the indicated character represents whitespace in the font,
 * or false if anything visible will be rendered for it.
 *
 * This returns true for whitespace and Unicode whitespace characters (if they
 * exist in the font), and returns false for any other characters, including
 * characters that do not exist in the font (these would be rendered with the
 * "invalid glyph", which is visible).
 *
 * Note that this function can be reliably used to identify Unicode whitespace
 * characters only if the font has all of the whitespace characters defined.
 * It will return false for any character not in the font, even if it is an
 * official Unicode whitespace character.
 */
94
static bool TextAssembler::is_whitespace(wchar_t character, TextProperties const &properties);

690 19 upcast_to_PandaNode 0 12 899 29 TextNode::upcast_to_PandaNode 0 1 382 33
upcast from TextNode to PandaNode
47
PandaNode *TextNode::upcast_to_PandaNode(void);

691 20 downcast_to_TextNode 0 12 900 31 PandaNode::downcast_to_TextNode 0 1 383 35
downcast from PandaNode to TextNode
48
TextNode *PandaNode::downcast_to_TextNode(void);

692 21 upcast_to_TextEncoder 0 12 899 31 TextNode::upcast_to_TextEncoder 0 1 384 35
upcast from TextNode to TextEncoder
51
TextEncoder *TextNode::upcast_to_TextEncoder(void);

693 20 downcast_to_TextNode 0 12 901 33 TextEncoder::downcast_to_TextNode 0 1 385 37
downcast from TextEncoder to TextNode
50
TextNode *TextEncoder::downcast_to_TextNode(void);

694 24 upcast_to_TextProperties 0 12 899 34 TextNode::upcast_to_TextProperties 0 1 386 38
upcast from TextNode to TextProperties
57
TextProperties *TextNode::upcast_to_TextProperties(void);

695 20 downcast_to_TextNode 0 12 882 36 TextProperties::downcast_to_TextNode 0 1 387 40
downcast from TextProperties to TextNode
53
TextNode *TextProperties::downcast_to_TextNode(void);

696 8 TextNode 0 4 899 18 TextNode::TextNode 0 2 266 267 184
/**
 *
 */

/**
 * It's sort of a copy constructor: it copies the indicated TextProperties,
 * without copying a complete TextNode.
 */

/**
 * OK, this is a true copy constructor.
 */
117
TextNode::TextNode(std::string const &name);
TextNode::TextNode(std::string const &name, TextProperties const &copy);

697 9 ~TextNode 0 6 899 19 TextNode::~TextNode 0 0 10
/**
 *
 */
34
virtual TextNode::~TextNode(void);

698 15 get_line_height 0 4 899 25 TextNode::get_line_height 0 1 268 234
/**
 * Returns the number of units high each line of text is.  This is based on
 * the font.  Note that it is possible for the text to include nested font
 * change commands, in which case the value of this method is questionable.
 */
57
inline PN_stdfloat TextNode::get_line_height(void) const;

699 12 set_max_rows 0 4 899 22 TextNode::set_max_rows 0 1 269 183
/**
 * Sets the maximum number of rows that may be formatted by the TextNode.  If
 * more text than this is attempted, it will be truncated and has_overflow()
 * will return true.
 */
49
inline void TextNode::set_max_rows(int max_rows);

700 14 clear_max_rows 0 4 899 24 TextNode::clear_max_rows 0 1 270 96
/**
 * Resets the TextNode's default behavior of not limiting the number of rows
 * of text.
 */
43
inline void TextNode::clear_max_rows(void);

701 12 has_max_rows 0 4 899 22 TextNode::has_max_rows 0 1 271 117
/**
 * Returns true if a limit on the height of the TextNode has been set via
 * set_max_rows(), false otherwise.
 */
47
inline bool TextNode::has_max_rows(void) const;

702 12 get_max_rows 0 4 899 22 TextNode::get_max_rows 0 1 272 90
/**
 * Returns the limit on the height of the TextNode specified by
 * set_max_rows().
 */
46
inline int TextNode::get_max_rows(void) const;

703 12 has_overflow 0 4 899 22 TextNode::has_overflow 0 1 273 122
/**
 * Returns true if the last text set on the text node exceeded the max_rows
 * constraint, or false if it all fit.
 */
47
inline bool TextNode::has_overflow(void) const;

704 15 set_frame_color 0 4 899 25 TextNode::set_frame_color 0 2 274 275 22
/**
 *
 */

/**
 *
 */
164
inline void TextNode::set_frame_color(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b, PN_stdfloat a);
inline void TextNode::set_frame_color(LColor const &frame_color);

705 15 get_frame_color 0 4 899 25 TextNode::get_frame_color 0 1 276 10
/**
 *
 */
52
inline LColor TextNode::get_frame_color(void) const;

706 15 set_card_border 0 4 899 25 TextNode::set_card_border 0 1 277 10
/**
 *
 */
80
inline void TextNode::set_card_border(PN_stdfloat size, PN_stdfloat uv_portion);

707 17 clear_card_border 0 4 899 27 TextNode::clear_card_border 0 1 278 10
/**
 *
 */
46
inline void TextNode::clear_card_border(void);

708 20 get_card_border_size 0 4 899 30 TextNode::get_card_border_size 0 1 279 10
/**
 *
 */
62
inline PN_stdfloat TextNode::get_card_border_size(void) const;

709 26 get_card_border_uv_portion 0 4 899 36 TextNode::get_card_border_uv_portion 0 1 280 10
/**
 *
 */
68
inline PN_stdfloat TextNode::get_card_border_uv_portion(void) const;

710 15 has_card_border 0 4 899 25 TextNode::has_card_border 0 1 281 10
/**
 *
 */
50
inline bool TextNode::has_card_border(void) const;

711 14 set_card_color 0 4 899 24 TextNode::set_card_color 0 2 282 283 22
/**
 *
 */

/**
 *
 */
161
inline void TextNode::set_card_color(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b, PN_stdfloat a);
inline void TextNode::set_card_color(LColor const &card_color);

712 14 get_card_color 0 4 899 24 TextNode::get_card_color 0 1 284 10
/**
 *
 */
51
inline LColor TextNode::get_card_color(void) const;

713 16 set_card_texture 0 4 899 26 TextNode::set_card_texture 0 1 285 10
/**
 *
 */
62
inline void TextNode::set_card_texture(Texture *card_texture);

714 18 clear_card_texture 0 4 899 28 TextNode::clear_card_texture 0 1 286 10
/**
 *
 */
47
inline void TextNode::clear_card_texture(void);

715 16 has_card_texture 0 4 899 26 TextNode::has_card_texture 0 1 287 10
/**
 *
 */
51
inline bool TextNode::has_card_texture(void) const;

716 16 get_card_texture 0 4 899 26 TextNode::get_card_texture 0 1 288 10
/**
 *
 */
55
inline Texture *TextNode::get_card_texture(void) const;

717 19 set_frame_as_margin 0 4 899 29 TextNode::set_frame_as_margin 0 1 289 249
/**
 * Specifies that a border will be drawn around the text when it is next
 * created.  The parameters are the amount of additional padding to insert
 * between the frame and the text in each dimension, and all should generally
 * be positive.
 */
116
inline void TextNode::set_frame_as_margin(PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top);

718 16 set_frame_actual 0 4 899 26 TextNode::set_frame_actual 0 1 290 308
/**
 * Similar to set_frame_as_margin, except the frame is specified in actual
 * coordinate units (relative to the text's origin), irrespective of the size
 * of the text.  The left and bottom coordinates should generally be negative,
 * while the right and top coordinates should generally be positive.
 */
113
inline void TextNode::set_frame_actual(PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top);

719 11 clear_frame 0 4 899 21 TextNode::clear_frame 0 1 291 69
/**
 * Specifies that a border will not be drawn around the text.
 */
40
inline void TextNode::clear_frame(void);

720 9 has_frame 0 4 899 19 TextNode::has_frame 0 1 292 10
/**
 *
 */
44
inline bool TextNode::has_frame(void) const;

721 18 is_frame_as_margin 0 4 899 28 TextNode::is_frame_as_margin 0 1 293 368
/**
 * If this is true, the frame was set via a call to set_frame_as_margin(), and
 * the dimension of the frame as returned by get_frame_as_set() represent a
 * margin all around the text.  If false, then the frame was set via a call to
 * set_frame_actual(), and the dimensions of the frame as returned by
 * get_frame_as_set() are relative to the text's origin.
 */
53
inline bool TextNode::is_frame_as_margin(void) const;

722 16 get_frame_as_set 0 4 899 26 TextNode::get_frame_as_set 0 1 294 255
/**
 * Returns the dimensions of the frame as set by set_frame_as_margin() or
 * set_frame_actual().  Use is_frame_actual() to determine how to interpret
 * the values returned by this function.  It is an error to call this if
 * has_frame() is false.
 */
56
inline LVecBase4 TextNode::get_frame_as_set(void) const;

723 16 get_frame_actual 0 4 899 26 TextNode::get_frame_actual 0 1 295 431
/**
 * Returns the actual dimensions of the frame around the text.  If the frame
 * was set via set_frame_as_margin(), the result returned by this function
 * reflects the size of the current text; if the frame was set via
 * set_frame_actual(), this returns the values actually set.
 *
 * If the text has no frame at all, this returns the dimensions of the text
 * itself, as if the frame were set with a margin of 0, 0, 0, 0.
 */
56
inline LVecBase4 TextNode::get_frame_actual(void) const;

724 20 set_frame_line_width 0 4 899 30 TextNode::set_frame_line_width 0 1 296 84
/**
 * Specifies the thickness of the lines that will be used to draw the frame.
 */
67
inline void TextNode::set_frame_line_width(PN_stdfloat line_width);

725 20 get_frame_line_width 0 4 899 30 TextNode::get_frame_line_width 0 1 297 82
/**
 * Returns the thickness of the lines that will be used to draw the frame.
 */
62
inline PN_stdfloat TextNode::get_frame_line_width(void) const;

726 17 set_frame_corners 0 4 899 27 TextNode::set_frame_corners 0 1 298 209
/**
 * Enables or disables the drawing of corners for the frame.  These are extra
 * points drawn at each of the four corners, to soften the ugly edges
 * generated when the line width is greater than one.
 */
54
inline void TextNode::set_frame_corners(bool corners);

727 17 get_frame_corners 0 4 899 27 TextNode::get_frame_corners 0 1 299 10
/**
 *
 */
52
inline bool TextNode::get_frame_corners(void) const;

728 18 set_card_as_margin 0 4 899 28 TextNode::set_card_as_margin 0 1 300 294
/**
 * Specifies that a (possibly opaque or semitransparent) card will be held
 * behind the text when it is next created.  Like set_frame_as_margin, the
 * parameters are the amount of additional padding to insert around the text
 * in each dimension, and all should generally be positive.
 */
115
inline void TextNode::set_card_as_margin(PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top);

729 15 set_card_actual 0 4 899 25 TextNode::set_card_actual 0 1 301 306
/**
 * Similar to set_card_as_margin, except the card is specified in actual
 * coordinate units (relative to the text's origin), irrespective of the size
 * of the text.  The left and bottom coordinates should generally be negative,
 * while the right and top coordinates should generally be positive.
 */
112
inline void TextNode::set_card_actual(PN_stdfloat left, PN_stdfloat right, PN_stdfloat bottom, PN_stdfloat top);

730 14 set_card_decal 0 4 899 24 TextNode::set_card_decal 0 1 302 197
/**
 * Sets the card_decal flag.  When this is true, the text is decalled onto the
 * card, which is necessary if the TextNode is to be rendered in the 3-d world
 * without putting it in a bin.
 */
54
inline void TextNode::set_card_decal(bool card_decal);

731 10 clear_card 0 4 899 20 TextNode::clear_card 0 1 303 67
/**
 * Specifies that a card will not be drawn behind the text.
 */
39
inline void TextNode::clear_card(void);

732 8 has_card 0 4 899 18 TextNode::has_card 0 1 304 10
/**
 *
 */
43
inline bool TextNode::has_card(void) const;

733 14 get_card_decal 0 4 899 24 TextNode::get_card_decal 0 1 305 62
/**
 * Returns the card_decal flag.  See set_card_decal().
 */
49
inline bool TextNode::get_card_decal(void) const;

734 17 is_card_as_margin 0 4 899 27 TextNode::is_card_as_margin 0 1 306 360
/**
 * If this is true, the card was set via a call to set_card_as_margin(), and
 * the dimension of the card as returned by get_card_as_set() represent a
 * margin all around the text.  If false, then the card was set via a call to
 * set_card_actual(), and the dimensions of the card as returned by
 * get_card_as_set() are relative to the text's origin.
 */
52
inline bool TextNode::is_card_as_margin(void) const;

735 15 get_card_as_set 0 4 899 25 TextNode::get_card_as_set 0 1 307 250
/**
 * Returns the dimensions of the card as set by set_card_as_margin() or
 * set_card_actual().  Use is_card_actual() to determine how to interpret the
 * values returned by this function.  It is an error to call this if
 * has_card() is false.
 */
55
inline LVecBase4 TextNode::get_card_as_set(void) const;

736 15 get_card_actual 0 4 899 25 TextNode::get_card_actual 0 1 308 424
/**
 * Returns the actual dimensions of the card around the text.  If the card was
 * set via set_card_as_margin(), the result returned by this function reflects
 * the size of the current text; if the card was set via set_card_actual(),
 * this returns the values actually set.
 *
 * If the text has no card at all, this returns the dimensions of the text
 * itself, as if the card were set with a margin of 0, 0, 0, 0.
 */
55
inline LVecBase4 TextNode::get_card_actual(void) const;

737 20 get_card_transformed 0 4 899 30 TextNode::get_card_transformed 0 1 309 251
/**
 * Returns the actual card dimensions, transformed by the matrix set by
 * set_transform().  This returns the card dimensions in actual coordinates as
 * seen by the rest of the world.  Also see get_upper_left_3d() and
 * get_lower_right_3d().
 */
60
inline LVecBase4 TextNode::get_card_transformed(void) const;

738 13 set_transform 0 4 899 23 TextNode::set_transform 0 1 310 85
/**
 * Sets an additional transform that is applied to the entire text paragraph.
 */
63
inline void TextNode::set_transform(LMatrix4 const &transform);

739 13 get_transform 0 4 899 23 TextNode::get_transform 0 1 311 10
/**
 *
 */
52
inline LMatrix4 TextNode::get_transform(void) const;

740 21 set_coordinate_system 0 4 899 31 TextNode::set_coordinate_system 0 1 312 79
/**
 * Specifies the coordinate system in which the text will be generated.
 */
65
inline void TextNode::set_coordinate_system(CoordinateSystem cs);

741 21 get_coordinate_system 0 4 899 31 TextNode::get_coordinate_system 0 1 313 10
/**
 *
 */
68
inline CoordinateSystem TextNode::get_coordinate_system(void) const;

742 14 set_usage_hint 0 4 899 24 TextNode::set_usage_hint 0 1 314 278
/**
 * Specifies the UsageHint that will be applied to generated geometry.  The
 * default is UH_static, which is probably the right setting, but if you know
 * the TextNode's geometry will have a short lifespan, it may be better to set
 * it to UH_stream.  See geomEnums.h.
 */
70
inline void TextNode::set_usage_hint(GeomEnums::UsageHint usage_hint);

743 14 get_usage_hint 0 4 899 24 TextNode::get_usage_hint 0 1 315 102
/**
 * Returns the UsageHint that will be applied to generated geometry.  See
 * set_usage_hint().
 */
65
inline GeomEnums::UsageHint TextNode::get_usage_hint(void) const;

744 17 set_flatten_flags 0 4 899 27 TextNode::set_flatten_flags 0 1 316 1534
/**
 * Sets the flatten flags.  This should be a union of the
 * TextNode::FlattenFlags options.  This controls the degree of flattening
 * performed on the TextNode's internal geometry (i.e.  the scene graph
 * returned by generate()) each time the text is changed.  In general, more
 * flattening means a more optimal result, but it will take more time to
 * generate.
 *
 * The choice may be any of these three:
 *
 * FF_none - No flatten operation is called.  The letters are left as
 * independent Geoms.
 *
 * FF_light - A flatten_light() operation is called.  The attributes are
 * applied to the vertices, but no nodes are removed.
 *
 * FF_medium - A flatten_medium() operation is called.  The attributes are
 * applied to the vertices, and a few trivial nodes are removed.
 *
 * FF_strong - A flatten_strong() operation is called.  The attributes are
 * applied to the vertices, and the resulting nodes are aggressively combined
 * into as few nodes as possible.
 *
 * In addition to the above choices, you may optionally include the following
 * flag:
 *
 * FF_dynamic_merge - Copy the geoms into a single GeomVertexData as we go,
 * instead of relying on the flatten operation at the end.  This pre-flattens
 * the text considerably, and may obviate the need for flatten altogether; it
 * also tends to improve performance considerably even if you do call flatten.
 * However, it is not as fast as not calling flatten at all.
 *
 * The default is taken from the text-flatten and text-dynamic-merge config
 * variables.
 */
59
inline void TextNode::set_flatten_flags(int flatten_flags);

745 17 get_flatten_flags 0 4 899 27 TextNode::get_flatten_flags 0 1 317 63
/**
 * Returns the flatten flags.  See set_flatten_flags().
 */
51
inline int TextNode::get_flatten_flags(void) const;

746 8 set_font 0 4 899 18 TextNode::set_font 0 1 318 160
/**
 * Sets the font that will be used when making text.  If this is set to NULL,
 * the default font will be used, which can be set via set_default_font().
 */
47
inline void TextNode::set_font(TextFont *font);

747 10 clear_font 0 4 899 20 TextNode::clear_font 0 1 319 47
/**
 * Resets the font to the default font.
 */
39
inline void TextNode::clear_font(void);

748 14 set_small_caps 0 4 899 24 TextNode::set_small_caps 0 1 320 707
/**
 * Sets the small_caps flag.  When this is set, lowercase letters are
 * generated as scaled-down versions of their uppercase equivalents.  This is
 * particularly useful to set for fonts that do not have lowercase letters.
 *
 * It is also a good idea to set this for a (dynamic) font that has already
 * implemented lowercase letters as scaled-down versions of their uppercase
 * equivalents, since without this flag the texture memory may needlessly
 * duplicate equivalent glyphs for upper and lowercase letters.  Setting this
 * flag causes the texture memory to share the mixed-case letters.
 *
 * The amount by which the lowercase letters are scaled is specified by
 * set_small_caps_scale().
 */
54
inline void TextNode::set_small_caps(bool small_caps);

749 16 clear_small_caps 0 4 899 26 TextNode::clear_small_caps 0 1 321 10
/**
 *
 */
45
inline void TextNode::clear_small_caps(void);

750 20 set_small_caps_scale 0 4 899 30 TextNode::set_small_caps_scale 0 1 322 210
/**
 * Sets the scale factor applied to lowercase letters from their uppercase
 * equivalents, when the small_caps flag is in effect.  See set_small_caps().
 * Normally, this will be a number less than one.
 */
73
inline void TextNode::set_small_caps_scale(PN_stdfloat small_caps_scale);

751 22 clear_small_caps_scale 0 4 899 32 TextNode::clear_small_caps_scale 0 1 323 10
/**
 *
 */
51
inline void TextNode::clear_small_caps_scale(void);

752 9 set_slant 0 4 899 19 TextNode::set_slant 0 1 324 10
/**
 *
 */
51
inline void TextNode::set_slant(PN_stdfloat slant);

753 11 clear_slant 0 4 899 21 TextNode::clear_slant 0 1 325 10
/**
 *
 */
40
inline void TextNode::clear_slant(void);

754 9 set_align 0 4 899 19 TextNode::set_align 0 1 326 10
/**
 *
 */
70
inline void TextNode::set_align(TextProperties::Alignment align_type);

755 11 clear_align 0 4 899 21 TextNode::clear_align 0 1 327 10
/**
 *
 */
40
inline void TextNode::clear_align(void);

756 10 set_indent 0 4 899 20 TextNode::set_indent 0 1 328 149
/**
 * Specifies the amount of extra space that is inserted before the first
 * character of each line.  This can be thought of as a left margin.
 */
53
inline void TextNode::set_indent(PN_stdfloat indent);

757 12 clear_indent 0 4 899 22 TextNode::clear_indent 0 1 329 10
/**
 *
 */
41
inline void TextNode::clear_indent(void);

758 12 set_wordwrap 0 4 899 22 TextNode::set_wordwrap 0 1 330 152
/**
 * Sets the text up to automatically wordwrap when it exceeds the indicated
 * width.  This can be thought of as a right margin or margin width.
 */
57
inline void TextNode::set_wordwrap(PN_stdfloat wordwrap);

759 14 clear_wordwrap 0 4 899 24 TextNode::clear_wordwrap 0 1 331 93
/**
 * Removes the wordwrap setting from the TextNode.  Text will be as wide as it
 * is.
 */
43
inline void TextNode::clear_wordwrap(void);

760 14 set_text_color 0 4 899 24 TextNode::set_text_color 0 2 332 333 22
/**
 *
 */

/**
 *
 */
161
inline void TextNode::set_text_color(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b, PN_stdfloat a);
inline void TextNode::set_text_color(LColor const &text_color);

761 16 clear_text_color 0 4 899 26 TextNode::clear_text_color 0 1 334 117
/**
 * Removes the text color specification; the text will be colored whatever it
 * was in the source font file.
 */
45
inline void TextNode::clear_text_color(void);

762 16 set_shadow_color 0 4 899 26 TextNode::set_shadow_color 0 2 335 336 22
/**
 *
 */

/**
 *
 */
167
inline void TextNode::set_shadow_color(PN_stdfloat r, PN_stdfloat g, PN_stdfloat b, PN_stdfloat a);
inline void TextNode::set_shadow_color(LColor const &shadow_color);

763 18 clear_shadow_color 0 4 899 28 TextNode::clear_shadow_color 0 1 337 10
/**
 *
 */
47
inline void TextNode::clear_shadow_color(void);

764 10 set_shadow 0 4 899 20 TextNode::set_shadow 0 2 338 339 304
/**
 * Specifies that the text should be drawn with a shadow, by creating a second
 * copy of the text and offsetting it slightly behind the first.
 */

/**
 * Specifies that the text should be drawn with a shadow, by creating a second
 * copy of the text and offsetting it slightly behind the first.
 */
141
inline void TextNode::set_shadow(PN_stdfloat xoffset, PN_stdfloat yoffset);
inline void TextNode::set_shadow(LVecBase2 const &shadow_offset);

765 12 clear_shadow 0 4 899 22 TextNode::clear_shadow 0 1 340 69
/**
 * Specifies that a shadow will not be drawn behind the text.
 */
41
inline void TextNode::clear_shadow(void);

766 7 set_bin 0 4 899 17 TextNode::set_bin 0 1 341 362
/**
 * Names the GeomBin that the TextNode geometry should be assigned to.  If
 * this is set, then a GeomBinTransition will be created to explicitly place
 * each component in the named bin.
 *
 * The draw_order value will also be passed to each GeomBinTransition as
 * appropriate; this is particularly useful if this names a GeomBinFixed, e.g.
 * "fixed".
 */
54
inline void TextNode::set_bin(std::string const &bin);

767 9 clear_bin 0 4 899 19 TextNode::clear_bin 0 1 342 158
/**
 * Removes the effect of a previous call to set_bin().  Text will be drawn in
 * whatever bin it would like to be drawn in, with no explicit ordering.
 */
38
inline void TextNode::clear_bin(void);

768 14 set_draw_order 0 4 899 24 TextNode::set_draw_order 0 1 343 435
/**
 * Sets the drawing order of text created by the TextMaker.  This is actually
 * the draw order of the card and frame.  The shadow is drawn at
 * _draw_order+1, and the text at _draw_order+2.
 *
 * This affects the sorting order assigned to the arcs as they are created,
 * and also is passed to whatever bin may be assigned via set_bin().
 *
 * The return value is the first unused draw_order number, e.g.  _draw_order +
 * 3.
 */
52
inline int TextNode::set_draw_order(int draw_order);

769 16 clear_draw_order 0 4 899 26 TextNode::clear_draw_order 0 1 344 10
/**
 *
 */
45
inline void TextNode::clear_draw_order(void);

770 13 set_tab_width 0 4 899 23 TextNode::set_tab_width 0 1 345 160
/**
 * Sets the width of each tab stop, in screen units.  A tab character embedded
 * in the text will advance the horizontal position to the next tab stop.
 */
59
inline void TextNode::set_tab_width(PN_stdfloat tab_width);

771 15 clear_tab_width 0 4 899 25 TextNode::clear_tab_width 0 1 346 10
/**
 *
 */
44
inline void TextNode::clear_tab_width(void);

772 15 set_glyph_scale 0 4 899 25 TextNode::set_glyph_scale 0 1 347 208
/**
 * Specifies the factor by which to scale each letter of the text as it is
 * placed.  This can be used (possibly in conjunction with set_glyph_shift())
 * to implement superscripting or subscripting.
 */
63
inline void TextNode::set_glyph_scale(PN_stdfloat glyph_scale);

773 17 clear_glyph_scale 0 4 899 27 TextNode::clear_glyph_scale 0 1 348 10
/**
 *
 */
46
inline void TextNode::clear_glyph_scale(void);

774 15 set_glyph_shift 0 4 899 25 TextNode::set_glyph_shift 0 1 349 206
/**
 * Specifies a vertical amount to shift each letter of the text as it is
 * placed.  This can be used (possibly in conjunction with set_glyph_scale())
 * to implement superscripting or subscripting.
 */
63
inline void TextNode::set_glyph_shift(PN_stdfloat glyph_shift);

775 17 clear_glyph_shift 0 4 899 27 TextNode::clear_glyph_shift 0 1 350 10
/**
 *
 */
46
inline void TextNode::clear_glyph_shift(void);

776 8 set_text 0 4 899 18 TextNode::set_text 0 2 351 352 632
// These methods are inherited from TextEncoder, but we override here so we
// can flag the TextNode as dirty when they have been changed.

// These methods are inherited from TextEncoder, but we override here so we
// can flag the TextNode as dirty when they have been changed.

/**
 * Changes the text that is displayed under the TextNode.
 */

/**
 * The two-parameter version of set_text() accepts an explicit encoding; the
 * text is immediately decoded and stored as a wide-character string.
 * Subsequent calls to get_text() will return the same text re-encoded using
 * whichever encoding is specified by set_encoding().
 */
145
inline void TextNode::set_text(std::string const &text);
inline void TextNode::set_text(std::string const &text, TextEncoder::Encoding encoding);

777 10 clear_text 0 4 899 20 TextNode::clear_text 0 1 353 46
/**
 * Removes the text from the TextNode.
 */
39
inline void TextNode::clear_text(void);

778 11 append_text 0 4 899 21 TextNode::append_text 0 1 354 70
/**
 * Appends the indicates string to the end of the stored text.
 */
59
inline void TextNode::append_text(std::string const &text);

779 19 append_unicode_char 0 4 899 29 TextNode::append_unicode_char 0 1 355 128
/**
 * Appends a single character to the end of the stored text.  This may be a
 * wide character, up to 16 bits in Unicode.
 */
61
inline void TextNode::append_unicode_char(wchar_t character);

780 20 get_wordwrapped_text 0 4 899 30 TextNode::get_wordwrapped_text 0 1 356 323
// After the text has been set, you can query this to determine how it will
// be wordwrapped.

/**
 * Returns a string that represents the contents of the text, as it has been
 * formatted by wordwrap rules.
 *
 * In earlier versions, this did not contain any embedded special characters
 * like \1 or \3; now it does.
 */
62
inline std::string TextNode::get_wordwrapped_text(void) const;

781 10 calc_width 0 4 899 20 TextNode::calc_width 0 3 357 358 359 564
// These methods calculate the width of a single character or a line of text
// in the current font.

/**
 * Returns the width of a line of text of arbitrary characters.  The line
 * should not include the newline character.
 */

/**
 * Returns the width of a single character of the font, or 0.0 if the
 * character is not known.  This may be a wide character (greater than 255).
 */

/**
 * Returns the width of a line of text of arbitrary characters.  The line
 * should not include the newline character or any embedded control characters
 * like \1 or \3.
 */
196
PN_stdfloat TextNode::calc_width(wchar_t character) const;
inline PN_stdfloat TextNode::calc_width(std::string const &line) const;
PN_stdfloat TextNode::calc_width(std::wstring const &line) const;

782 19 has_exact_character 0 4 899 29 TextNode::has_exact_character 0 1 360 634
/**
 * Returns true if the named character exists in the font exactly as named,
 * false otherwise.  Note that because Panda can assemble glyphs together
 * automatically using cheesy accent marks, this is not a reliable indicator
 * of whether a suitable glyph can be rendered for the character.  For that,
 * use has_character() instead.
 *
 * This returns true for whitespace and Unicode whitespace characters (if they
 * exist in the font), but returns false for characters that would render with
 * the "invalid glyph".  It also returns false for characters that would be
 * synthesized within Panda, but see has_character().
 */
60
bool TextNode::has_exact_character(wchar_t character) const;

783 13 has_character 0 4 899 23 TextNode::has_character 0 1 361 405
/**
 * Returns true if the named character exists in the font or can be
 * synthesized by Panda, false otherwise.  (Panda can synthesize some accented
 * characters by combining similar-looking glyphs from the font.)
 *
 * This returns true for whitespace and Unicode whitespace characters (if they
 * exist in the font), but returns false for characters that would render with
 * the "invalid glyph".
 */
54
bool TextNode::has_character(wchar_t character) const;

784 13 is_whitespace 0 4 899 23 TextNode::is_whitespace 0 1 362 695
/**
 * Returns true if the indicated character represents whitespace in the font,
 * or false if anything visible will be rendered for it.
 *
 * This returns true for whitespace and Unicode whitespace characters (if they
 * exist in the font), and returns false for any other characters, including
 * characters that do not exist in the font (these would be rendered with the
 * "invalid glyph", which is visible).
 *
 * Note that this function can be reliably used to identify Unicode whitespace
 * characters only if the font has all of the whitespace characters defined.
 * It will return false for any character not in the font, even if it is an
 * official Unicode whitespace character.
 */
54
bool TextNode::is_whitespace(wchar_t character) const;

785 9 set_wtext 0 4 899 19 TextNode::set_wtext 0 1 363 243
// Direct support for wide-character strings.

/**
 * Changes the text that is displayed under the TextNode, with a wide text.
 * This automatically sets the string reported by get_text() to the 8-bit
 * encoded version of the same string.
 */
59
inline void TextNode::set_wtext(std::wstring const &wtext);

786 12 append_wtext 0 4 899 22 TextNode::append_wtext 0 1 364 85
/**
 * Appends the indicates string to the end of the stored wide-character text.
 */
61
inline void TextNode::append_wtext(std::wstring const &text);

787 21 get_wordwrapped_wtext 0 4 899 31 TextNode::get_wordwrapped_wtext 0 1 365 228
/**
 * Returns a wstring that represents the contents of the text, as it has been
 * formatted by wordwrap rules.
 *
 * In earlier versions, this did not contain any embedded special characters
 * like \1 or \3; now it does.
 */
64
inline std::wstring TextNode::get_wordwrapped_wtext(void) const;

788 6 output 0 6 899 16 TextNode::output 0 1 366 10
/**
 *
 */
50
virtual void TextNode::output(ostream &out) const;

789 5 write 0 6 899 15 TextNode::write 0 1 367 10
/**
 *
 */
71
virtual void TextNode::write(ostream &out, int indent_level = 0) const;

790 8 get_left 0 4 899 18 TextNode::get_left 0 1 368 234
// The following functions return information about the text that was last
// built (and is currently visible).

/**
 * Returns the leftmost extent of the text in local 2-d coordinates,
 * unmodified by the set_transform() matrix.
 */
50
inline PN_stdfloat TextNode::get_left(void) const;

791 9 get_right 0 4 899 19 TextNode::get_right 0 1 369 122
/**
 * Returns the rightmost extent of the text in local 2-d coordinates,
 * unmodified by the set_transform() matrix.
 */
51
inline PN_stdfloat TextNode::get_right(void) const;

792 10 get_bottom 0 4 899 20 TextNode::get_bottom 0 1 370 123
/**
 * Returns the bottommost extent of the text in local 2-d coordinates,
 * unmodified by the set_transform() matrix.
 */
52
inline PN_stdfloat TextNode::get_bottom(void) const;

793 7 get_top 0 4 899 17 TextNode::get_top 0 1 371 120
/**
 * Returns the topmost extent of the text in local 2-d coordinates, unmodified
 * by the set_transform() matrix.
 */
49
inline PN_stdfloat TextNode::get_top(void) const;

794 10 get_height 0 4 899 20 TextNode::get_height 0 1 372 71
/**
 * Returns the net height of the text in local 2-d coordinates.
 */
52
inline PN_stdfloat TextNode::get_height(void) const;

795 9 get_width 0 4 899 19 TextNode::get_width 0 1 373 70
/**
 * Returns the net width of the text in local 2-d coordinates.
 */
51
inline PN_stdfloat TextNode::get_width(void) const;

796 17 get_upper_left_3d 0 4 899 27 TextNode::get_upper_left_3d 0 1 374 148
/**
 * Returns the upper-left extent of the text object, after it has been
 * transformed into 3-d space by applying the set_transform() matrix.
 */
55
inline LPoint3 TextNode::get_upper_left_3d(void) const;

797 18 get_lower_right_3d 0 4 899 28 TextNode::get_lower_right_3d 0 1 375 149
/**
 * Returns the lower-right extent of the text object, after it has been
 * transformed into 3-d space by applying the set_transform() matrix.
 */
56
inline LPoint3 TextNode::get_lower_right_3d(void) const;

798 12 get_num_rows 0 4 899 22 TextNode::get_num_rows 0 1 376 153
/**
 * Returns the number of rows of text that were generated.  This counts word-
 * wrapped rows as well as rows generated due to embedded newlines.
 */
46
inline int TextNode::get_num_rows(void) const;

799 8 generate 0 4 899 18 TextNode::generate 0 1 377 168
/**
 * Generates the text, according to the parameters indicated within the
 * TextNode, and returns a Node that may be parented within the tree to
 * represent it.
 */
48
PointerTo< PandaNode > TextNode::generate(void);

800 6 update 0 4 899 16 TextNode::update 0 1 378 193
/**
 * Can be called after the TextNode has been fully configured, to force the
 * node to recompute its text immediately, rather than waiting for it to be
 * drawn.  This call is optional.
 */
35
inline void TextNode::update(void);

801 12 force_update 0 4 899 22 TextNode::force_update 0 1 379 267
/**
 * Forces the TextNode to recompute itself now, even if it believes nothing
 * has changed.  Normally, this should not need to be called, but it may be
 * useful if some properties change outside of the TextNode's knowledge (for
 * instance, within the font).
 */
41
inline void TextNode::force_update(void);

802 17 get_internal_geom 0 4 899 27 TextNode::get_internal_geom 0 1 380 331
/**
 * Returns the actual node that is used internally to render the text, if the
 * TextNode is parented within the scene graph.
 *
 * In general, you should not call this method.  Call generate() instead if
 * you want to get a handle to geometry that represents the text.  This method
 * is provided as a debugging aid only.
 */
51
PandaNode *TextNode::get_internal_geom(void) const;

803 8 get_text 0 4 899 18 TextNode::get_text 0 1 388 0
50
inline std::string TextNode::get_text(void) const;

804 8 get_font 0 4 899 18 TextNode::get_font 0 1 389 110
/**
 * Returns the font currently in use, if any.  If no font is in use, this
 * returns the default font.
 */
48
inline TextFont *TextNode::get_font(void) const;

805 8 has_font 0 4 899 18 TextNode::has_font 0 1 390 10
/**
 *
 */
43
inline bool TextNode::has_font(void) const;

806 14 get_small_caps 0 4 899 24 TextNode::get_small_caps 0 1 391 62
/**
 * Returns the small_caps flag.  See set_small_caps().
 */
49
inline bool TextNode::get_small_caps(void) const;

807 14 has_small_caps 0 4 899 24 TextNode::has_small_caps 0 1 392 10
/**
 *
 */
49
inline bool TextNode::has_small_caps(void) const;

808 20 get_small_caps_scale 0 4 899 30 TextNode::get_small_caps_scale 0 1 393 193
/**
 * Returns the scale factor applied to lowercase letters from their uppercase
 * equivalents, when the small_caps flag is in effect.  See set_small_caps()
 * and set_small_caps_scale().
 */
62
inline PN_stdfloat TextNode::get_small_caps_scale(void) const;

809 20 has_small_caps_scale 0 4 899 30 TextNode::has_small_caps_scale 0 1 394 10
/**
 *
 */
55
inline bool TextNode::has_small_caps_scale(void) const;

810 9 get_slant 0 4 899 19 TextNode::get_slant 0 1 395 83
/**
 * Returns the factor by which the text is specified to slant to the right.
 */
51
inline PN_stdfloat TextNode::get_slant(void) const;

811 9 has_slant 0 4 899 19 TextNode::has_slant 0 1 396 10
/**
 *
 */
44
inline bool TextNode::has_slant(void) const;

812 14 get_underscore 0 4 899 24 TextNode::get_underscore 0 1 398 62
/**
 * Returns the underscore flag.  See set_underscore().
 */
49
inline bool TextNode::get_underscore(void) const;

813 14 has_underscore 0 4 899 24 TextNode::has_underscore 0 1 399 10
/**
 *
 */
49
inline bool TextNode::has_underscore(void) const;

814 14 set_underscore 0 4 899 24 TextNode::set_underscore 0 1 397 169
/**
 * Sets the underscore flag.  When this is set, the text is underscored with a
 * one-pixel line the same color as the text foreground, drawn at the
 * baseline.
 */
54
inline void TextNode::set_underscore(bool underscore);

815 16 clear_underscore 0 4 899 26 TextNode::clear_underscore 0 1 400 10
/**
 *
 */
45
inline void TextNode::clear_underscore(void);

816 21 get_underscore_height 0 4 899 31 TextNode::get_underscore_height 0 1 402 86
/**
 * Returns the vertical height of the underscore; see set_underscore_height().
 */
63
inline PN_stdfloat TextNode::get_underscore_height(void) const;

817 21 has_underscore_height 0 4 899 31 TextNode::has_underscore_height 0 1 403 10
/**
 *
 */
56
inline bool TextNode::has_underscore_height(void) const;

818 21 set_underscore_height 0 4 899 31 TextNode::set_underscore_height 0 1 401 176
/**
 * Specifies the vertical height of the underscore, relative to the text
 * baseline.  This only has meaning if the underscore mode is enabled with
 * set_underscore().
 */
75
inline void TextNode::set_underscore_height(PN_stdfloat underscore_height);

819 23 clear_underscore_height 0 4 899 33 TextNode::clear_underscore_height 0 1 404 10
/**
 *
 */
52
inline void TextNode::clear_underscore_height(void);

820 9 get_align 0 4 899 19 TextNode::get_align 0 1 405 10
/**
 *
 */
65
inline TextProperties::Alignment TextNode::get_align(void) const;

821 9 has_align 0 4 899 19 TextNode::has_align 0 1 406 10
/**
 *
 */
44
inline bool TextNode::has_align(void) const;

822 10 get_indent 0 4 899 20 TextNode::get_indent 0 1 407 10
/**
 *
 */
52
inline PN_stdfloat TextNode::get_indent(void) const;

823 10 has_indent 0 4 899 20 TextNode::has_indent 0 1 408 10
/**
 *
 */
45
inline bool TextNode::has_indent(void) const;

824 12 get_wordwrap 0 4 899 22 TextNode::get_wordwrap 0 1 409 10
/**
 *
 */
54
inline PN_stdfloat TextNode::get_wordwrap(void) const;

825 12 has_wordwrap 0 4 899 22 TextNode::has_wordwrap 0 1 410 10
/**
 *
 */
47
inline bool TextNode::has_wordwrap(void) const;

826 32 get_preserve_trailing_whitespace 0 4 899 42 TextNode::get_preserve_trailing_whitespace 0 1 412 101
/**
 * Returns the preserve_trailing_whitespace flag.  See
 * set_preserve_trailing_whitespace().
 */
67
inline bool TextNode::get_preserve_trailing_whitespace(void) const;

827 32 has_preserve_trailing_whitespace 0 4 899 42 TextNode::has_preserve_trailing_whitespace 0 1 413 10
/**
 *
 */
67
inline bool TextNode::has_preserve_trailing_whitespace(void) const;

828 32 set_preserve_trailing_whitespace 0 4 899 42 TextNode::set_preserve_trailing_whitespace 0 1 411 344
/**
 * Sets the preserve_trailing_whitespace flag.  When this is set, trailing
 * whitespace at the end of the line is not stripped when the text is
 * wordwrapped (it is stripped by default).  Since the trailing whitespace is
 * invisible, this is important primarily for determining the proper width of
 * a frame or card behind the text.
 */
90
inline void TextNode::set_preserve_trailing_whitespace(bool preserve_trailing_whitespace);

829 34 clear_preserve_trailing_whitespace 0 4 899 44 TextNode::clear_preserve_trailing_whitespace 0 1 414 10
/**
 *
 */
63
inline void TextNode::clear_preserve_trailing_whitespace(void);

830 14 get_text_color 0 4 899 24 TextNode::get_text_color 0 1 415 10
/**
 *
 */
51
inline LColor TextNode::get_text_color(void) const;

831 14 has_text_color 0 4 899 24 TextNode::has_text_color 0 1 416 10
/**
 *
 */
49
inline bool TextNode::has_text_color(void) const;

832 16 get_shadow_color 0 4 899 26 TextNode::get_shadow_color 0 1 417 10
/**
 *
 */
53
inline LColor TextNode::get_shadow_color(void) const;

833 16 has_shadow_color 0 4 899 26 TextNode::has_shadow_color 0 1 418 10
/**
 *
 */
51
inline bool TextNode::has_shadow_color(void) const;

834 10 get_shadow 0 4 899 20 TextNode::get_shadow 0 1 419 125
/**
 * Returns the offset of the shadow as set by set_shadow().  It is an error to
 * call this if has_shadow() is false.
 */
49
inline LVector2 TextNode::get_shadow(void) const;

835 10 has_shadow 0 4 899 20 TextNode::has_shadow 0 1 420 10
/**
 *
 */
45
inline bool TextNode::has_shadow(void) const;

836 7 get_bin 0 4 899 17 TextNode::get_bin 0 1 421 97
/**
 * Returns the drawing bin set with set_bin(), or empty string if no bin has
 * been set.
 */
56
inline std::string const &TextNode::get_bin(void) const;

837 7 has_bin 0 4 899 17 TextNode::has_bin 0 1 422 98
/**
 * Returns true if an explicit drawing bin has been set via set_bin(), false
 * otherwise.
 */
42
inline bool TextNode::has_bin(void) const;

838 14 get_draw_order 0 4 899 24 TextNode::get_draw_order 0 1 423 63
/**
 * Returns the drawing order set with set_draw_order().
 */
48
inline int TextNode::get_draw_order(void) const;

839 14 has_draw_order 0 4 899 24 TextNode::has_draw_order 0 1 424 10
/**
 *
 */
49
inline bool TextNode::has_draw_order(void) const;

840 13 get_tab_width 0 4 899 23 TextNode::get_tab_width 0 1 425 53
/**
 * Returns the width set via set_tab_width().
 */
55
inline PN_stdfloat TextNode::get_tab_width(void) const;

841 13 has_tab_width 0 4 899 23 TextNode::has_tab_width 0 1 426 10
/**
 *
 */
48
inline bool TextNode::has_tab_width(void) const;

842 15 get_glyph_scale 0 4 899 25 TextNode::get_glyph_scale 0 1 427 85
/**
 * Returns the scale factor of each letter as specified by set_glyph_scale().
 */
57
inline PN_stdfloat TextNode::get_glyph_scale(void) const;

843 15 has_glyph_scale 0 4 899 25 TextNode::has_glyph_scale 0 1 428 10
/**
 *
 */
50
inline bool TextNode::has_glyph_scale(void) const;

844 15 get_glyph_shift 0 4 899 25 TextNode::get_glyph_shift 0 1 429 90
/**
 * Returns the vertical shift of each letter as specified by
 * set_glyph_shift().
 */
57
inline PN_stdfloat TextNode::get_glyph_shift(void) const;

845 15 has_glyph_shift 0 4 899 25 TextNode::has_glyph_shift 0 1 430 10
/**
 *
 */
50
inline bool TextNode::has_glyph_shift(void) const;

846 14 get_text_scale 0 4 899 24 TextNode::get_text_scale 0 1 432 81
/**
 * Returns the scale factor of the text as specified by set_text_scale().
 */
56
inline PN_stdfloat TextNode::get_text_scale(void) const;

847 14 has_text_scale 0 4 899 24 TextNode::has_text_scale 0 1 433 10
/**
 *
 */
49
inline bool TextNode::has_text_scale(void) const;

848 14 set_text_scale 0 4 899 24 TextNode::set_text_scale 0 1 431 284
/**
 * Specifies the factor by which to scale the text, in addition to any
 * scalings imposed by the node, as well as in addition to the glyph scale.
 *
 * The text scale is not cumulative when applied to nested TextProperties.
 * See also set_glyph_scale(), which is cumulative.
 */
61
inline void TextNode::set_text_scale(PN_stdfloat text_scale);

849 16 clear_text_scale 0 4 899 26 TextNode::clear_text_scale 0 1 434 10
/**
 *
 */
45
inline void TextNode::clear_text_scale(void);

850 14 get_class_type 0 4 899 24 TextNode::get_class_type 0 1 381 0
49
static TypeHandle TextNode::get_class_type(void);

434
1 0 0 6 3 853 0 0 96 /**
 * Returns the Unicode value that corresponds to the character this glyph
 * represents.
 */ 1 4 this 3 907  
2 0 0 6 4 862 0 0 239 /**
 * Returns true if this glyph contains the definition for a simple quad,
 * rather than a more complex piece of geometry.
 *
 * You may still call get_geom() even if this returns true, which will
 * synthesize a Geom for this quad.
 */ 1 4 this 3 907  
3 0 0 6 5 862 0 0 255 /**
 * Assuming that this glyph is representable as a textured quad, returns its
 * dimensions and UV range.  Returns false if it is not representable as a
 * quad, or if it is whitespace.
 *
 * The order of the components is left, bottom, right, top.
 */ 3 4 this 3 907  10 dimensions 1 909  9 texcoords 1 909  
4 0 0 7 6 854 0 0 67 /**
 * Returns the state in which the glyph should be rendered.
 */ 1 4 this 3 907  
5 0 0 6 7 857 0 0 181 /**
 * Returns the distance by which the character pointer should be advanced
 * after placing this character; i.e.  the approximate width the character
 * takes up on the line.
 */ 1 4 this 3 907  
6 0 0 6 17 862 0 0 127 /**
 * Returns true if this glyph represents invisible whitespace, or false if it
 * corresponds to some visible character.
 */ 1 4 this 3 907  
7 0 0 7 18 910 0 0 195 /**
 * Returns a Geom that renders the particular glyph.  It will be generated if
 * necessary.
 *
 * This method will always return a copy of the Geom, so the caller is free to
 * modify it.
 */ 2 4 this 3 907  10 usage_hint 1 896  
8 0 0 7 19 912 0 0 0 0 
9 0 0 7 28 885 447 0 0 1 4 this 3 913  
10 0 0 6 29 862 0 0 79 /**
 * Returns true if the font is valid and ready to use, false otherwise.
 */ 1 4 this 3 913  
11 0 0 6 31 857 0 0 65 /**
 * Returns the number of units high each line of text is.
 */ 1 4 this 3 913  
12 0 0 4 32 915 0 0 65 /**
 * Changes the number of units high each line of text is.
 */ 2 4 this 3 885  11 line_height 1 857  
13 0 0 6 36 857 0 0 55 /**
 * Returns the number of units wide a space is.
 */ 1 4 this 3 913  
14 0 0 4 37 915 0 0 55 /**
 * Changes the number of units wide a space is.
 */ 2 4 this 3 885  13 space_advance 1 857  
15 0 0 7 39 907 0 0 294 /**
 * Gets the glyph associated with the given character code, as well as an
 * optional scaling parameter that should be applied to the glyph's geometry
 * and advance parameters.  Returns the glyph on success.  On failure, it may
 * still return a printable glyph, or it may return NULL.
 */ 2 4 this 3 885  9 character 1 853  
16 0 0 6 40 857 0 0 180 /**
 * Returns the amount by which to offset the second glyph when it directly
 * follows the first glyph.  This is an additional offset that is added on top
 * of the advance.
 */ 3 4 this 3 913  5 first 1 853  6 second 1 853  
17 0 0 4 41 915 0 0 10 /**
 *
 */ 3 4 this 3 913  3 out 1 916  12 indent_level 1 853  
18 0 0 7 42 912 0 0 0 0 
19 0 0 6 30 862 0 0 0 1 4 this 3 913  
20 0 0 7 21 918 0 0 0 1 4 this 3 885  
21 0 0 7 22 885 447 0 0 1 4 this 3 918  
22 0 0 6 24 919 0 0 0 1 4 this 3 885  
23 0 0 7 25 885 447 0 0 1 4 this 3 919  
24 0 0 7 44 864 466 0 61 /**
 * Returns the DynamicTextPage that this glyph is on.
 */ 1 4 this 3 920  
25 0 0 6 56 862 0 0 207 /**
 * Returns true if the particular position this glyph has been assigned to
 * overlaps the rectangle whose top left corner is at x, y and whose size is
 * given by x_size, y_size, or false otherwise.
 */ 5 4 this 3 920  1 x 1 853  1 y 1 853  6 x_size 1 853  6 y_size 1 853  
26 0 0 6 57 857 0 0 99 /**
 * Returns the vertex coordinates that can be used when creating a custom text
 * renderer.
 */ 1 4 this 3 920  
27 0 0 6 58 857 0 0 99 /**
 * Returns the vertex coordinates that can be used when creating a custom text
 * renderer.
 */ 1 4 this 3 920  
28 0 0 6 59 857 0 0 99 /**
 * Returns the vertex coordinates that can be used when creating a custom text
 * renderer.
 */ 1 4 this 3 920  
29 0 0 6 60 857 0 0 99 /**
 * Returns the vertex coordinates that can be used when creating a custom text
 * renderer.
 */ 1 4 this 3 920  
30 0 0 6 61 857 0 0 95 /**
 * Returns the UV coordinates that can be used when creating a custom text
 * renderer.
 */ 1 4 this 3 920  
31 0 0 6 62 857 0 0 95 /**
 * Returns the UV coordinates that can be used when creating a custom text
 * renderer.
 */ 1 4 this 3 920  
32 0 0 6 63 857 0 0 95 /**
 * Returns the UV coordinates that can be used when creating a custom text
 * renderer.
 */ 1 4 this 3 920  
33 0 0 6 64 857 0 0 95 /**
 * Returns the UV coordinates that can be used when creating a custom text
 * renderer.
 */ 1 4 this 3 920  
34 0 0 7 65 912 0 0 0 0 
35 0 0 7 54 864 466 0 0 1 6 param0 0 922  
36 0 0 6 49 924 0 0 61 /**
 * Returns the size of the page (texture), in pixels.
 */ 1 4 this 3 922  
37 0 0 6 50 853 0 0 63 /**
 * Returns the x size of the page (texture), in pixels.
 */ 1 4 this 3 922  
38 0 0 6 51 853 0 0 63 /**
 * Returns the y size of the page (texture), in pixels.
 */ 1 4 this 3 922  
39 0 0 6 52 862 0 0 67 /**
 * Returns true if the page has no glyphs, false otherwise.
 */ 1 4 this 3 922  
40 0 0 7 53 912 0 0 0 0 
41 0 0 7 72 927 482 0 10 /**
 *
 */ 1 4 copy 1 925  
42 0 0 7 72 927 482 0 173 /**
 * The constructor expects the name of some font file that FreeType can read,
 * along with face_index, indicating which font within the file to load
 * (usually 0).
 */ 2 13 font_filename 1 928  10 face_index 1 853  
43 0 0 7 72 927 482 0 137 /**
 * This constructor accepts a table of data representing the font file, loaded
 * from some source other than a filename on disk.
 */ 3 9 font_data 1 931  11 data_length 1 853  10 face_index 1 853  
44 0 0 7 74 885 447 0 47 /**
 * Returns a new copy of the same font.
 */ 1 4 this 3 925  
45 0 0 6 75 931 0 0 124 /**
 * Disambiguates the get_name() method between that inherited from TextFont
 * and that inherited from FreetypeFont.
 */ 1 4 this 3 925  
46 0 0 6 76 862 0 0 295 /**
 * Sets the point size of the font.  This controls the apparent size of the
 * font onscreen.  By convention, a 10 point font is about 1 screen unit high.
 *
 * This should only be called before any characters have been requested out of
 * the font, or immediately after calling clear().
 */ 2 4 this 3 927  10 point_size 1 857  
47 0 0 6 77 857 0 0 46 /**
 * Returns the point size of the font.
 */ 1 4 this 3 925  
48 0 0 6 79 862 0 0 433 /**
 * Set the resolution of the texture map, and hence the clarity of the
 * resulting font.  This sets the number of pixels in the texture map that are
 * used for each onscreen unit.
 *
 * Setting this number larger results in an easier to read font, but at the
 * cost of more texture memory.
 *
 * This should only be called before any characters have been requested out of
 * the font, or immediately after calling clear().
 */ 2 4 this 3 927  15 pixels_per_unit 1 857  
49 0 0 6 80 857 0 0 81 /**
 * Returns the resolution of the texture map.  See set_pixels_per_unit().
 */ 1 4 this 3 925  
50 0 0 6 82 862 0 0 591 /**
 * Sets the factor by which the font is rendered larger by the FreeType
 * library before being filtered down to its actual size in the texture as
 * specified by set_pixels_per_unit().  This may be set to a number larger
 * than 1.0 to improve the font's antialiasing (since FreeType doesn't really
 * do a swell job of antialiasing by itself).  There is some performance
 * implication for setting this different than 1.0, but it is probably small.
 *
 * This should only be called before any characters have been requested out of
 * the font, or immediately after calling clear().
 */ 2 4 this 3 927  12 scale_factor 1 857  
51 0 0 6 83 857 0 0 74 /**
 * Returns the antialiasing scale factor.  See set_scale_factor().
 */ 1 4 this 3 925  
52 0 0 4 85 915 0 0 469 /**
 * Sets whether the Freetype library's built-in antialias mode is enabled.
 * There are two unrelated ways to achieve antialiasing: with Freetype's
 * native antialias mode, and with the use of a scale_factor greater than one.
 * By default, both modes are enabled.
 *
 * At low resolutions, some fonts may do better with one mode or the other.
 * In general, Freetype's native antialiasing will produce less blurry
 * results, but may introduce more artifacts.
 */ 2 4 this 3 927  16 native_antialias 1 862  
53 0 0 6 86 862 0 0 105 /**
 * Returns whether Freetype's built-in antialias mode is enabled.  See
 * set_native_antialias().
 */ 1 4 this 3 925  
54 0 0 6 88 853 0 0 386 /**
 * This is used to report whether the requested pixel size is being only
 * approximated by a fixed-pixel-size font.  This returns 0 in the normal
 * case, in which a scalable font is used, or the fixed-pixel-size font has
 * exactly the requested pixel size.
 *
 * If this returns non-zero, it is the pixel size of the font that we are
 * using to approximate our desired size.
 */ 1 4 this 3 925  
55 0 0 6 90 857 0 0 65 /**
 * Returns the number of units high each line of text is.
 */ 1 4 this 3 925  
56 0 0 6 91 857 0 0 55 /**
 * Returns the number of units wide a space is.
 */ 1 4 this 3 925  
57 0 0 4 92 915 0 0 207 /**
 * Sets the number of pixels of padding that is added around the border of
 * each glyph before adding it to the texture map.  This reduces the bleed in
 * from neighboring glyphs in the texture map.
 */ 2 4 this 3 927  14 texture_margin 1 853  
58 0 0 6 93 853 0 0 146 /**
 * Returns the number of pixels of padding that is added around the border of
 * each glyph in the texture map.  See set_texture_margin().
 */ 1 4 this 3 925  
59 0 0 4 94 915 0 0 452 /**
 * Sets the number of pixels of padding that is included around each glyph in
 * the generated polygons.  This helps prevent the edges of the glyphs from
 * being cut off at small minifications.  It is not related to the amount of
 * extra pixels reserved in the texture map (but it should be set somewhat
 * smaller than this number, which is controlled by set_texture_margin(), to
 * prevent bleed-in from neighboring letters in the texture).
 */ 2 4 this 3 927  11 poly_margin 1 857  
60 0 0 6 95 857 0 0 139 /**
 * Returns the number of pixels of padding that is included around each glyph
 * in the generated polygons.  See set_poly_margin().
 */ 1 4 this 3 925  
61 0 0 4 98 915 0 0 90 /**
 * Sets the x, y size of the textures that are created for the
 * DynamicTextFont.
 */ 2 4 this 3 927  9 page_size 1 924  
62 0 0 4 98 915 0 0 90 /**
 * Sets the x, y size of the textures that are created for the
 * DynamicTextFont.
 */ 3 4 this 3 927  6 x_size 1 853  6 y_size 1 853  
63 0 0 6 99 924 0 0 109 /**
 * Returns the size of the textures that are created for the DynamicTextFont.
 * See set_page_size().
 */ 1 4 this 3 925  
64 0 0 6 100 853 0 0 112 /**
 * Returns the x size of the textures that are created for the
 * DynamicTextFont.  See set_page_size().
 */ 1 4 this 3 925  
65 0 0 6 101 853 0 0 112 /**
 * Returns the y size of the textures that are created for the
 * DynamicTextFont.  See set_page_size().
 */ 1 4 this 3 925  
66 0 0 4 105 915 0 0 91 /**
 * Sets the filter type used when minimizing the textures created for this
 * font.
 */ 2 4 this 3 927  6 filter 1 871  
67 0 0 6 106 871 0 0 94 /**
 * Returns the filter type used when minimizing the textures created for this
 * font.
 */ 1 4 this 3 925  
68 0 0 4 107 915 0 0 90 /**
 * Sets the filter type used when enlarging the textures created for this
 * font.
 */ 2 4 this 3 927  6 filter 1 871  
69 0 0 6 108 871 0 0 93 /**
 * Returns the filter type used when enlarging the textures created for this
 * font.
 */ 1 4 this 3 925  
70 0 0 4 109 915 0 0 210 /**
 * Enables or disables anisotropic filtering on the textures created for this
 * font.  The default value is specified by the text-anisotropic-degree
 * variable.  See Texture::set_anisotropic_degree().
 */ 2 4 this 3 927  18 anisotropic_degree 1 853  
71 0 0 6 110 853 0 0 118 /**
 * Returns the current anisotropic degree for textures created for this font.
 * See set_anisotropic_degree().
 */ 1 4 this 3 925  
72 0 0 4 116 915 0 0 211 /**
 * Specifies the way the glyphs on this particular font are generated.  The
 * default is RM_texture, which is the only mode supported for bitmap fonts.
 * Other modes are possible for most modern fonts.
 */ 2 4 this 3 927  11 render_mode 1 861  
73 0 0 6 117 861 0 0 103 /**
 * Returns the way the glyphs on this particular font are generated.  See
 * set_render_mode().
 */ 1 4 this 3 925  
74 0 0 4 119 915 0 0 485 /**
 * Changes the color of the foreground pixels of the font as they are rendered
 * into the font texture.  The default is (1, 1, 1, 1), or opaque white, which
 * allows text created with the font to be colored individually.  Normally,
 * you would not change this unless you really need a particular color effect
 * to appear in the font itself.
 *
 * This should only be called before any characters have been requested out of
 * the font, or immediately after calling clear().
 */ 2 4 this 3 927  2 fg 1 932  
75 0 0 6 120 932 0 0 127 /**
 * Returns the color of the foreground pixels of the font as they are rendered
 * into the font texture.  See set_fg().
 */ 1 4 this 3 925  
76 0 0 4 121 915 0 0 673 /**
 * Changes the color of the background pixels of the font as they are rendered
 * into the font texture.  The default is (1, 1, 1, 0), or transparent white,
 * which allows text created with the font to be colored individually.  (Note
 * that it should not generally be (0, 0, 0, 0), which would tend to bleed
 * into the foreground color, unless you have also specified a outline color
 * of (0, 0, 0, 1)) .
 *
 * Normally, you would not change this unless you really need a particular
 * color effect to appear in the font itself.
 *
 * This should only be called before any characters have been requested out of
 * the font, or immediately after calling clear().
 */ 2 4 this 3 927  2 bg 1 932  
77 0 0 6 122 932 0 0 127 /**
 * Returns the color of the background pixels of the font as they are rendered
 * into the font texture.  See set_bg().
 */ 1 4 this 3 925  
78 0 0 4 123 915 0 0 722 /**
 * Sets up the font to have an outline around each font letter.  This is
 * achieved via a Gaussian post-process as each letter is generated; there is
 * some runtime cost for this effect, but it is minimal as each letter is
 * normally generated only once and then cached.
 *
 * The color is the desired color of the outline, width is the number of
 * points beyond the letter that the outline extends (a typical font is 10
 * points high), and feather is a number in the range 0.0 .. 1.0 that controls
 * the softness of the outline.  Set the width to 0.0 to disable the outline.
 *
 * This should only be called before any characters have been requested out of
 * the font, or immediately after calling clear().
 */ 4 4 this 3 927  13 outline_color 1 932  13 outline_width 1 857  15 outline_feather 1 857  
79 0 0 6 124 932 0 0 129 /**
 * Returns the color of the outline pixels of the font as they are rendered
 * into the font texture.  See set_outline().
 */ 1 4 this 3 925  
80 0 0 6 125 857 0 0 130 /**
 * Returns the width of the outline pixels of the font, as the number of
 * points beyond each letter.  See set_outline().
 */ 1 4 this 3 925  
81 0 0 6 126 857 0 0 124 /**
 * Returns the softness of the outline pixels of the font, as a value in the
 * range 0.0 to 1.0. See set_outline().
 */ 1 4 this 3 925  
82 0 0 6 127 877 0 0 138 /**
 * Returns the texture format used to render the individual pages.  This is
 * set automatically according to the colors selected.
 */ 1 4 this 3 925  
83 0 0 6 136 853 0 0 313 /**
 * Returns the number of pages associated with the font.  Initially, the font
 * has zero pages; when the first piece of text is rendered with the font, it
 * will add additional pages as needed.  Each page is a Texture object that
 * contains the images for each of the glyphs currently in use somewhere.
 */ 1 4 this 3 925  
84 0 0 7 137 864 466 0 306 /**
 * Returns the nth page associated with the font.  Initially, the font has
 * zero pages; when the first piece of text is rendered with the font, it will
 * add additional pages as needed.  Each page is a Texture object that
 * contains the images for each of the glyphs currently in use somewhere.
 */ 2 4 this 3 925  1 n 1 853  
85 0 0 6 140 853 0 0 136 /**
 * Removes all of the glyphs from the font that are no longer being used by
 * any Geoms.  Returns the number of glyphs removed.
 */ 1 4 this 3 927  
86 0 0 4 141 915 0 0 385 /**
 * Drops all the glyphs out of the cache and frees any association with any
 * previously-generated pages.
 *
 * Calling this frequently can result in wasted texture memory, as any
 * previously rendered text will still keep a pointer to the old, previously-
 * generated pages.  As long as the previously rendered text remains around,
 * the old pages will also remain around.
 */ 1 4 this 3 927  
87 0 0 4 142 915 0 0 10 /**
 *
 */ 3 4 this 3 925  3 out 1 916  12 indent_level 1 853  
88 0 0 7 143 912 0 0 0 0 
89 0 0 7 67 885 447 0 0 1 4 this 3 927  
90 0 0 7 68 927 482 0 0 1 4 this 3 885  
91 0 0 6 70 933 0 0 0 1 4 this 3 927  
92 0 0 7 71 927 482 0 0 1 4 this 3 933  
93 0 0 6 145 862 0 0 74 /**
 * Returns true if the font has ever been loaded, false otherwise.
 */ 1 8 filename 1 931  
94 0 0 6 146 862 0 0 299 /**
 * Loads the given filename up into a font, if it has not already been loaded,
 * and returns true to indicate success, or false to indicate failure.  If
 * this returns true, it is guaranteed that a subsequent call to load_font()
 * with the same font name will return a valid Font pointer.
 */ 1 8 filename 1 931  
95 0 0 7 147 885 447 0 253 /**
 * Loads the given filename up into a font, if it has not already been loaded,
 * and returns the new font.  If a font with the same filename was previously
 * loaded, returns that one instead.  If the font file cannot be found,
 * returns NULL.
 */ 1 8 filename 1 931  
96 0 0 4 148 915 0 0 162 /**
 * Adds the indicated already-loaded font to the pool.  The font will always
 * replace any previously-loaded font in the pool that had the same filename.
 */ 2 8 filename 1 931  4 font 1 885  
97 0 0 4 149 915 0 0 262 /**
 * Removes the indicated font from the pool, indicating it will never be
 * loaded again; the font may then be freed.  If this function is never
 * called, a reference count will be maintained on every font every loaded,
 * and fonts will never be freed.
 */ 1 8 filename 1 931  
98 0 0 4 150 915 0 0 83 /**
 * Releases all fonts in the pool and restores the pool to the empty state.
 */ 0 
99 0 0 6 151 853 0 0 203 /**
 * Releases only those fonts in the pool that have a reference count of
 * exactly 1; i.e.  only those fonts that are not being used outside of the
 * pool.  Returns the number of fonts released.
 */ 0 
100 0 0 4 152 915 0 0 78 /**
 * Lists the contents of the font pool to the indicated output stream.
 */ 1 3 out 1 916  
101 0 0 4 153 915 0 0 78 /**
 * Lists the contents of the font pool to the indicated output stream.
 */ 1 3 out 1 916  
102 0 0 7 157 912 0 0 0 0 
103 0 0 7 159 935 540 0 374 /**
 * The constructor expects the root node to a model generated via egg-mkfont,
 * which consists of a set of models, one per each character in the font.
 *
 * If a CoordinateSystem value is specified, it informs the font of the
 * coordinate system in which this model was generated.  "up" in this
 * coordinate system will be the direction of the top of the letters.
 */ 2 8 font_def 1 934  2 cs 1 906  
104 0 0 7 160 912 0 0 0 0 
105 0 0 7 165 936 632 0 10 /**
 *
 */ 0 
106 0 0 7 165 936 632 0 10 /**
 *
 */ 1 4 copy 1 937  
107 0 0 6 166 936 0 0 0 2 4 this 3 936  4 copy 1 937  
108 0 0 6 167 862 0 0 0 2 4 this 3 937  5 other 1 937  
109 0 0 6 168 862 0 0 0 2 4 this 3 937  5 other 1 937  
110 0 0 4 169 915 0 0 136 /**
 * Unsets all properties that have been specified so far, and resets the
 * TextProperties structure to its initial empty state.
 */ 1 4 this 3 936  
111 0 0 6 170 862 0 0 79 /**
 * Returns true if any properties have been specified, false otherwise.
 */ 1 4 this 3 937  
112 0 0 4 171 915 0 0 122 /**
 * Specifies the default font to be used for any TextNode whose font is
 * uninitialized or NULL.  See set_font().
 */ 1 6 param0 0 885  
113 0 0 7 172 885 447 0 122 /**
 * Specifies the default font to be used for any TextNode whose font is
 * uninitialized or NULL.  See set_font().
 */ 0 
114 0 0 4 173 915 0 0 160 /**
 * Sets the font that will be used when making text.  If this is set to NULL,
 * the default font will be used, which can be set via set_default_font().
 */ 2 4 this 3 936  4 font 1 885  
115 0 0 4 174 915 0 0 49 /**
 * Restores the default font to the text.
 */ 1 4 this 3 936  
116 0 0 6 175 862 0 0 10 /**
 *
 */ 1 4 this 3 937  
117 0 0 7 176 885 447 0 110 /**
 * Returns the font currently in use, if any.  If no font is in use, this
 * returns the default font.
 */ 1 4 this 3 937  
118 0 0 4 177 915 0 0 707 /**
 * Sets the small_caps flag.  When this is set, lowercase letters are
 * generated as scaled-down versions of their uppercase equivalents.  This is
 * particularly useful to set for fonts that do not have lowercase letters.
 *
 * It is also a good idea to set this for a (dynamic) font that has already
 * implemented lowercase letters as scaled-down versions of their uppercase
 * equivalents, since without this flag the texture memory may needlessly
 * duplicate equivalent glyphs for upper and lowercase letters.  Setting this
 * flag causes the texture memory to share the mixed-case letters.
 *
 * The amount by which the lowercase letters are scaled is specified by
 * set_small_caps_scale().
 */ 2 4 this 3 936  10 small_caps 1 862  
119 0 0 4 178 915 0 0 10 /**
 *
 */ 1 4 this 3 936  
120 0 0 6 179 862 0 0 10 /**
 *
 */ 1 4 this 3 937  
121 0 0 6 180 862 0 0 62 /**
 * Returns the small_caps flag.  See set_small_caps().
 */ 1 4 this 3 937  
122 0 0 4 181 915 0 0 210 /**
 * Sets the scale factor applied to lowercase letters from their uppercase
 * equivalents, when the small_caps flag is in effect.  See set_small_caps().
 * Normally, this will be a number less than one.
 */ 2 4 this 3 936  16 small_caps_scale 1 857  
123 0 0 4 182 915 0 0 10 /**
 *
 */ 1 4 this 3 936  
124 0 0 6 183 862 0 0 10 /**
 *
 */ 1 4 this 3 937  
125 0 0 6 184 857 0 0 193 /**
 * Returns the scale factor applied to lowercase letters from their uppercase
 * equivalents, when the small_caps flag is in effect.  See set_small_caps()
 * and set_small_caps_scale().
 */ 1 4 this 3 937  
126 0 0 4 185 915 0 0 70 /**
 * Specifies the factor by which the text slants to the right.
 */ 2 4 this 3 936  5 slant 1 857  
127 0 0 4 186 915 0 0 10 /**
 *
 */ 1 4 this 3 936  
128 0 0 6 187 862 0 0 10 /**
 *
 */ 1 4 this 3 937  
129 0 0 6 188 857 0 0 83 /**
 * Returns the factor by which the text is specified to slant to the right.
 */ 1 4 this 3 937  
130 0 0 4 189 915 0 0 169 /**
 * Sets the underscore flag.  When this is set, the text is underscored with a
 * one-pixel line the same color as the text foreground, drawn at the
 * baseline.
 */ 2 4 this 3 936  10 underscore 1 862  
131 0 0 4 190 915 0 0 10 /**
 *
 */ 1 4 this 3 936  
132 0 0 6 191 862 0 0 10 /**
 *
 */ 1 4 this 3 937  
133 0 0 6 192 862 0 0 62 /**
 * Returns the underscore flag.  See set_underscore().
 */ 1 4 this 3 937  
134 0 0 4 193 915 0 0 176 /**
 * Specifies the vertical height of the underscore, relative to the text
 * baseline.  This only has meaning if the underscore mode is enabled with
 * set_underscore().
 */ 2 4 this 3 936  17 underscore_height 1 857  
135 0 0 4 194 915 0 0 10 /**
 *
 */ 1 4 this 3 936  
136 0 0 6 195 862 0 0 10 /**
 *
 */ 1 4 this 3 937  
137 0 0 6 196 857 0 0 86 /**
 * Returns the vertical height of the underscore; see set_underscore_height().
 */ 1 4 this 3 937  
138 0 0 4 197 915 0 0 66 /**
 * Specifies the alignment of the text within its margins.
 */ 2 4 this 3 936  10 align_type 1 883  
139 0 0 4 198 915 0 0 54 /**
 * Restores the default alignment of the text.
 */ 1 4 this 3 936  
140 0 0 6 199 862 0 0 10 /**
 *
 */ 1 4 this 3 937  
141 0 0 6 200 883 0 0 10 /**
 *
 */ 1 4 this 3 937  
142 0 0 4 201 915 0 0 149 /**
 * Specifies the amount of extra space that is inserted before the first
 * character of each line.  This can be thought of as a left margin.
 */ 2 4 this 3 936  6 indent 1 857  
143 0 0 4 202 915 0 0 84 /**
 * Removes the indent setting from the text.  Text will be as wide as it is.
 */ 1 4 this 3 936  
144 0 0 6 203 862 0 0 10 /**
 *
 */ 1 4 this 3 937  
145 0 0 6 204 857 0 0 10 /**
 *
 */ 1 4 this 3 937  
146 0 0 4 205 915 0 0 152 /**
 * Sets the text up to automatically wordwrap when it exceeds the indicated
 * width.  This can be thought of as a right margin or margin width.
 */ 2 4 this 3 936  8 wordwrap 1 857  
147 0 0 4 206 915 0 0 86 /**
 * Removes the wordwrap setting from the text.  Text will be as wide as it is.
 */ 1 4 this 3 936  
148 0 0 6 207 862 0 0 10 /**
 *
 */ 1 4 this 3 937  
149 0 0 6 208 857 0 0 10 /**
 *
 */ 1 4 this 3 937  
150 0 0 4 209 915 0 0 344 /**
 * Sets the preserve_trailing_whitespace flag.  When this is set, trailing
 * whitespace at the end of the line is not stripped when the text is
 * wordwrapped (it is stripped by default).  Since the trailing whitespace is
 * invisible, this is important primarily for determining the proper width of
 * a frame or card behind the text.
 */ 2 4 this 3 936  28 preserve_trailing_whitespace 1 862  
151 0 0 4 210 915 0 0 10 /**
 *
 */ 1 4 this 3 936  
152 0 0 6 211 862 0 0 10 /**
 *
 */ 1 4 this 3 937  
153 0 0 6 212 862 0 0 101 /**
 * Returns the preserve_trailing_whitespace flag.  See
 * set_preserve_trailing_whitespace().
 */ 1 4 this 3 937  
154 0 0 4 213 915 0 0 10 /**
 *
 */ 2 4 this 3 936  10 text_color 1 932  
155 0 0 4 213 915 0 0 10 /**
 *
 */ 5 4 this 3 936  1 r 1 857  1 g 1 857  1 b 1 857  1 a 1 857  
156 0 0 4 214 915 0 0 117 /**
 * Removes the text color specification; the text will be colored whatever it
 * was in the source font file.
 */ 1 4 this 3 936  
157 0 0 6 215 862 0 0 10 /**
 *
 */ 1 4 this 3 937  
158 0 0 7 216 938 0 0 10 /**
 *
 */ 1 4 this 3 937  
159 0 0 4 217 915 0 0 10 /**
 *
 */ 2 4 this 3 936  12 shadow_color 1 932  
160 0 0 4 217 915 0 0 10 /**
 *
 */ 5 4 this 3 936  1 r 1 857  1 g 1 857  1 b 1 857  1 a 1 857  
161 0 0 4 218 915 0 0 50 /**
 * Removes the shadow color specification.
 */ 1 4 this 3 936  
162 0 0 6 219 862 0 0 10 /**
 *
 */ 1 4 this 3 937  
163 0 0 7 220 938 0 0 10 /**
 *
 */ 1 4 this 3 937  
164 0 0 4 221 915 0 0 151 /**
 * Specifies that the text should be drawn with a shadow, by creating a second
 * copy of the text and offsetting it slightly behind the first.
 */ 2 4 this 3 936  13 shadow_offset 1 939  
165 0 0 4 221 915 0 0 151 /**
 * Specifies that the text should be drawn with a shadow, by creating a second
 * copy of the text and offsetting it slightly behind the first.
 */ 3 4 this 3 936  7 xoffset 1 857  7 yoffset 1 857  
166 0 0 4 222 915 0 0 69 /**
 * Specifies that a shadow will not be drawn behind the text.
 */ 1 4 this 3 936  
167 0 0 6 223 862 0 0 10 /**
 *
 */ 1 4 this 3 937  
168 0 0 7 224 943 0 0 125 /**
 * Returns the offset of the shadow as set by set_shadow().  It is an error to
 * call this if has_shadow() is false.
 */ 1 4 this 3 937  
169 0 0 4 225 915 0 0 350 /**
 * Names the CullBin that the text geometry should be assigned to.  If this is
 * set, then a CullBinAttrib will be created to explicitly place each
 * component in the named bin.
 *
 * The draw_order value will also be passed to each CullBinAttrib as
 * appropriate; this is particularly useful if this names a CullBinFixed, e.g.
 * "fixed".
 */ 2 4 this 3 936  3 bin 1 931  
170 0 0 4 226 915 0 0 158 /**
 * Removes the effect of a previous call to set_bin().  Text will be drawn in
 * whatever bin it would like to be drawn in, with no explicit ordering.
 */ 1 4 this 3 936  
171 0 0 6 227 862 0 0 98 /**
 * Returns true if an explicit drawing bin has been set via set_bin(), false
 * otherwise.
 */ 1 4 this 3 937  
172 0 0 6 228 931 0 0 97 /**
 * Returns the drawing bin set with set_bin(), or empty string if no bin has
 * been set.
 */ 1 4 this 3 937  
173 0 0 6 229 853 0 0 435 /**
 * Sets the drawing order of text created by the TextNode.  This is actually
 * the draw order of the card and frame.  The shadow is drawn at
 * _draw_order+1, and the text at _draw_order+2.
 *
 * This affects the sorting order assigned to the nodes as they are created,
 * and also is passed to whatever bin may be assigned via set_bin().
 *
 * The return value is the first unused draw_order number, e.g.  _draw_order +
 * 3.
 */ 2 4 this 3 936  10 draw_order 1 853  
174 0 0 4 230 915 0 0 10 /**
 *
 */ 1 4 this 3 936  
175 0 0 6 231 862 0 0 10 /**
 *
 */ 1 4 this 3 937  
176 0 0 6 232 853 0 0 63 /**
 * Returns the drawing order set with set_draw_order().
 */ 1 4 this 3 937  
177 0 0 4 233 915 0 0 160 /**
 * Sets the width of each tab stop, in screen units.  A tab character embedded
 * in the text will advance the horizontal position to the next tab stop.
 */ 2 4 this 3 936  9 tab_width 1 857  
178 0 0 4 234 915 0 0 10 /**
 *
 */ 1 4 this 3 936  
179 0 0 6 235 862 0 0 10 /**
 *
 */ 1 4 this 3 937  
180 0 0 6 236 857 0 0 53 /**
 * Returns the width set via set_tab_width().
 */ 1 4 this 3 937  
181 0 0 4 237 915 0 0 576 /**
 * Specifies the factor by which to scale each letter of the text as it is
 * placed, in addition to any scales inherited from the node or from
 * set_text_scale(). This can be used (possibly in conjunction with
 * set_glyph_shift()) to implement superscripting or subscripting.
 *
 * The glyph scale is cumulative when applied to nested TextProperties.  It is
 * intended primarily for implementing superscripts, not for scaling the text
 * in general.  See also set_text_scale(), which is intended primarily for
 * scaling the text in general, and is not cumulative.
 */ 2 4 this 3 936  11 glyph_scale 1 857  
182 0 0 4 238 915 0 0 10 /**
 *
 */ 1 4 this 3 936  
183 0 0 6 239 862 0 0 10 /**
 *
 */ 1 4 this 3 937  
184 0 0 6 240 857 0 0 85 /**
 * Returns the scale factor of each letter as specified by set_glyph_scale().
 */ 1 4 this 3 937  
185 0 0 4 241 915 0 0 206 /**
 * Specifies a vertical amount to shift each letter of the text as it is
 * placed.  This can be used (possibly in conjunction with set_glyph_scale())
 * to implement superscripting or subscripting.
 */ 2 4 this 3 936  11 glyph_shift 1 857  
186 0 0 4 242 915 0 0 10 /**
 *
 */ 1 4 this 3 936  
187 0 0 6 243 862 0 0 10 /**
 *
 */ 1 4 this 3 937  
188 0 0 6 244 857 0 0 90 /**
 * Returns the vertical shift of each letter as specified by
 * set_glyph_shift().
 */ 1 4 this 3 937  
189 0 0 4 245 915 0 0 284 /**
 * Specifies the factor by which to scale the text, in addition to any
 * scalings imposed by the node, as well as in addition to the glyph scale.
 *
 * The text scale is not cumulative when applied to nested TextProperties.
 * See also set_glyph_scale(), which is cumulative.
 */ 2 4 this 3 936  10 text_scale 1 857  
190 0 0 4 246 915 0 0 10 /**
 *
 */ 1 4 this 3 936  
191 0 0 6 247 862 0 0 10 /**
 *
 */ 1 4 this 3 937  
192 0 0 6 248 857 0 0 81 /**
 * Returns the scale factor of the text as specified by set_text_scale().
 */ 1 4 this 3 937  
193 0 0 4 249 915 0 0 122 /**
 * Specifies the text direction.  If none is specified, it will be guessed
 * based on the contents of the string.
 */ 2 4 this 3 936  9 direction 1 884  
194 0 0 4 250 915 0 0 140 /**
 * Clears the text direction setting.  If no text direction is specified, it
 * will be guessed based on the contents of the string.
 */ 1 4 this 3 936  
195 0 0 6 251 862 0 0 10 /**
 *
 */ 1 4 this 3 937  
196 0 0 6 252 884 0 0 77 /**
 * Returns the direction of the text as specified by set_direction().
 */ 1 4 this 3 937  
197 0 0 4 253 915 0 0 123 /**
 * Sets any properties that are explicitly specified in other on this object.
 * Leaves other properties unchanged.
 */ 2 4 this 3 936  5 other 1 937  
198 0 0 4 254 915 0 0 10 /**
 *
 */ 3 4 this 3 937  3 out 1 916  12 indent_level 1 853  
199 0 0 7 281 912 0 0 0 0 
200 0 0 7 284 944 640 0 10 /**
 *
 */ 0 
201 0 0 7 284 944 640 0 10 /**
 *
 */ 2 5 model 1 945  5 frame 1 947  
202 0 0 7 284 944 640 0 10 /**
 *
 */ 5 5 model 1 945  4 left 1 857  5 right 1 857  6 bottom 1 857  3 top 1 857  
203 0 0 7 284 944 640 0 0 1 6 param0 0 949  
204 0 0 7 285 951 0 0 95 /**
 * Returns the NodePath associated with the graphic, that renders the desired
 * image.
 */ 1 4 this 3 949  
205 0 0 4 286 915 0 0 146 /**
 * Changes the NodePath associated with the graphic.  This NodePath should
 * contain geometry that will render the desired graphic image.
 */ 2 4 this 3 944  5 model 1 945  
206 0 0 7 289 909 0 0 457 /**
 * Returns the frame specified for the graphic.  This is the amount of space
 * that will be reserved for the graphic when it is embedded in a text
 * paragraph, in the form (left, right, bottom, top).
 *
 * The actual graphic, as rendered by the NodePath specified via set_model(),
 * should more or less fit within this rectangle.  It is not required to fit
 * completely within it, but if it does not, it may visually overlap with
 * nearby text.
 */ 1 4 this 3 949  
207 0 0 4 290 915 0 0 103 /**
 * Specifies the (left, right, bottom, top) bounding frame for the graphic.
 * See get_frame().
 */ 2 4 this 3 944  5 frame 1 947  
208 0 0 4 290 915 0 0 103 /**
 * Specifies the (left, right, bottom, top) bounding frame for the graphic.
 * See get_frame().
 */ 5 4 this 3 944  4 left 1 857  5 right 1 857  6 bottom 1 857  3 top 1 857  
209 0 0 6 293 862 0 0 63 /**
 * Returns the instance_flag.  See set_instance_flag().
 */ 1 4 this 3 949  
210 0 0 4 294 915 0 0 355 /**
 * Sets the instance_flag.  When this is true, the graphic is directly
 * instanced to the scene graph whenever it appears; when it is false, the
 * graphic is copied.  The default is false, which is best for most
 * applications.  You might need to set it true for special kinds of
 * "graphics" like interactive elements, for instance a PGEntry.
 */ 2 4 this 3 944  13 instance_flag 1 862  
211 0 0 4 298 915 0 0 377 /**
 * Defines the TextProperties associated with the indicated name.  When the
 * name is subsequently encountered in text embedded between \1 characters in
 * a TextNode string, the following text will be rendered with these
 * properties.
 *
 * If there was already a TextProperties structure associated with this name,
 * it is quietly replaced with the new definition.
 */ 3 4 this 3 952  4 name 1 931  10 properties 1 937  
212 0 0 7 299 936 632 0 355 /**
 * Returns the TextProperties associated with the indicated name.  If there
 * was not previously a TextProperties associated with this name, a warning is
 * printed and then a default TextProperties structure is associated with the
 * name, and returned.
 *
 * Call has_properties() instead to check whether a particular name has been
 * defined.
 */ 2 4 this 3 952  4 name 1 931  
213 0 0 6 300 862 0 0 372 /**
 * Returns true if a TextProperties structure has been associated with the
 * indicated name, false otherwise.  Normally this means set_properties() has
 * been called with this name, but because get_properties() will implicitly
 * create a default TextProperties structure, it may also mean simply that
 * get_properties() has been called with the indicated name.
 */ 2 4 this 3 953  4 name 1 931  
214 0 0 4 301 915 0 0 71 /**
 * Removes the named TextProperties structure from the manager.
 */ 2 4 this 3 952  4 name 1 931  
215 0 0 4 302 915 0 0 271 /**
 * This flavor of set_graphic implicitly creates a frame for the model using
 * the model's actual computed bounding volume, as derived from
 * NodePath::calc_tight_bounds().  Create a TextGraphic object first if you
 * want to have explicit control of the frame.
 */ 3 4 this 3 952  4 name 1 931  5 model 1 945  
216 0 0 4 302 915 0 0 378 /**
 * Defines the TextGraphic associated with the indicated name.  When the name
 * is subsequently encountered in text embedded between \5 characters in a
 * TextNode string, the specified graphic will be embedded in the text at that
 * point.
 *
 * If there was already a TextGraphic structure associated with this name, it
 * is quietly replaced with the new definition.
 */ 3 4 this 3 952  4 name 1 931  7 graphic 1 949  
217 0 0 7 303 944 640 0 343 /**
 * Returns the TextGraphic associated with the indicated name.  If there was
 * not previously a TextGraphic associated with this name, a warning is
 * printed and then a default TextGraphic structure is associated with the
 * name, and returned.
 *
 * Call has_graphic() instead to check whether a particular name has been
 * defined.
 */ 2 4 this 3 952  4 name 1 931  
218 0 0 6 304 862 0 0 357 /**
 * Returns true if a TextGraphic structure has been associated with the
 * indicated name, false otherwise.  Normally this means set_graphic() has
 * been called with this name, but because get_graphic() will implicitly
 * create a default TextGraphic structure, it may also mean simply that
 * get_graphic() has been called with the indicated name.
 */ 2 4 this 3 953  4 name 1 931  
219 0 0 4 305 915 0 0 68 /**
 * Removes the named TextGraphic structure from the manager.
 */ 2 4 this 3 952  4 name 1 931  
220 0 0 4 306 915 0 0 10 /**
 *
 */ 3 4 this 3 953  3 out 1 916  12 indent_level 1 853  
221 0 0 6 307 952 0 0 74 /**
 * Returns the pointer to the global TextPropertiesManager object.
 */ 0 
222 0 0 7 309 957 653 0 10 /**
 *
 */ 1 4 copy 1 955  
223 0 0 7 309 957 653 0 10 /**
 *
 */ 1 7 encoder 1 958  
224 0 0 6 310 957 0 0 0 2 4 this 3 957  4 copy 1 955  
225 0 0 4 312 915 0 0 59 /**
 * Reinitializes the contents of the TextAssembler.
 */ 1 4 this 3 957  
226 0 0 4 313 915 0 0 278 /**
 * Specifies the UsageHint that will be applied to generated geometry.  The
 * default is UH_static, which is probably the right setting, but if you know
 * the TextNode's geometry will have a short lifespan, it may be better to set
 * it to UH_stream.  See geomEnums.h.
 */ 2 4 this 3 957  10 usage_hint 1 896  
227 0 0 6 314 896 0 0 102 /**
 * Returns the UsageHint that will be applied to generated geometry.  See
 * set_usage_hint().
 */ 1 4 this 3 955  
228 0 0 4 315 915 0 0 264 /**
 * If max_rows is greater than zero, no more than max_rows will be accepted.
 * Text beyond that will be truncated.
 *
 * Setting this will not truncate text immediately.  You must follow this up
 * with a call to set_wtext() to truncate the existing text.
 */ 2 4 this 3 957  8 max_rows 1 853  
229 0 0 6 316 853 0 0 123 /**
 * If max_rows is greater than zero, no more than max_rows will be accepted.
 * Text beyond that will be truncated.
 */ 1 4 this 3 955  
230 0 0 4 317 915 0 0 75 /**
 * Sets the dynamic_merge flag.  See TextNode::set_flatten_flags().
 */ 2 4 this 3 957  13 dynamic_merge 1 862  
231 0 0 6 318 862 0 0 78 /**
 * Returns the dynamic_merge flag.  See TextNode::set_flatten_flags().
 */ 1 4 this 3 955  
232 0 0 4 319 915 0 0 112 /**
 * Sets the multiline mode flag.  Set the multiline mode to allow text to
 * wrap.  It defaults to true.
 */ 2 4 this 3 957  4 flag 1 862  
233 0 0 6 320 862 0 0 79 /**
 * Returns the multline_mode flag.  See TextNode::set_multiline_mode().
 */ 1 4 this 3 955  
234 0 0 4 321 915 0 0 135 /**
 * Specifies the default TextProperties that are applied to the text in the
 * absence of any nested property change sequences.
 */ 2 4 this 3 957  10 properties 1 937  
235 0 0 6 322 937 0 0 133 /**
 * Returns the default TextProperties that are applied to the text in the
 * absence of any nested property change sequences.
 */ 1 4 this 3 955  
236 0 0 6 322 937 0 0 122 /**
 * Returns the TextProperties in effect for the object at the indicated
 * position in the pre-wordwrapped string.
 */ 2 4 this 3 955  1 n 1 853  
237 0 0 6 322 937 0 0 113 /**
 * Returns the TextProperties in effect for the object at the indicated
 * position in the indicated row.
 */ 3 4 this 3 955  1 r 1 853  1 c 1 853  
238 0 0 6 323 862 0 0 326 /**
 * Accepts a new text string and associated properties structure, and
 * precomputes the wordwrapping layout appropriately.  After this call,
 * get_wordwrapped_wtext() and get_num_rows() can be called.
 *
 * The return value is true if all the text is accepted, or false if some was
 * truncated (see set_max_rows()).
 */ 2 4 this 3 957  5 wtext 1 931  
239 0 0 6 324 862 0 0 595 /**
 * Replaces the 'count' characters from 'start' of the current text with the
 * indicated replacement text.  If the replacement text does not have count
 * characters, the length of the string will be changed accordingly.
 *
 * The substring may include nested formatting characters, but they must be
 * self-contained and self-closed.  The formatting characters are not
 * literally saved in the internal string; they are parsed at the time of the
 * set_wsubstr() call.
 *
 * The return value is true if all the text is accepted, or false if some was
 * truncated (see set_max_rows()).
 */ 4 4 this 3 957  5 wtext 1 931  5 start 1 853  5 count 1 853  
240 0 0 6 325 931 0 0 379 /**
 * Returns a wstring that represents the contents of the text, without any
 * embedded properties characters.  If there is an embedded graphic object, a
 * zero value is inserted in that position.
 *
 * This string has the same length as get_num_characters(), and the characters
 * in this string correspond one-to-one with the characters returned by
 * get_character(n).
 */ 1 4 this 3 955  
241 0 0 6 326 931 0 0 471 /**
 * Returns a wstring that represents the contents of the text, with newlines
 * inserted according to the wordwrapping.  The string will contain no
 * embedded properties characters.  If there is an embedded graphic object, a
 * zero value is inserted in that position.
 *
 * This string has the same number of newline characters as get_num_rows(),
 * and the characters in this string correspond one-to-one with the characters
 * returned by get_character(r, c).
 */ 1 4 this 3 955  
242 0 0 6 327 931 0 0 258 /**
 * Returns a wstring that represents the contents of the text.
 *
 * The string will contain embedded properties characters, which may not
 * exactly match the embedded properties characters of the original string,
 * but it will encode the same way.
 */ 1 4 this 3 955  
243 0 0 6 328 931 0 0 598 /**
 * Returns a wstring that represents the contents of the text, with newlines
 * inserted according to the wordwrapping.
 *
 * The string will contain embedded properties characters, which may not
 * exactly match the embedded properties characters of the original string,
 * but it will encode the same way.
 *
 * Embedded properties characters will be closed before every newline, then
 * reopened (if necessary) on the subsequent character following the newline.
 * This means it will be safe to divide the text up at the newline characters
 * and treat each line as an independent piece.
 */ 1 4 this 3 955  
244 0 0 6 330 853 0 0 330 /**
 * Computes the row index of the nth character or graphic object in the text
 * and returns it.
 *
 * If the nth character is not a normal printable character with a position in
 * the wordwrapped string, returns -1 (for instance, a soft-hyphen character,
 * or a newline character, may not have a corresponding position).
 */ 2 4 this 3 955  1 n 1 853  
245 0 0 6 331 853 0 0 333 /**
 * Computes the column index of the nth character or graphic object in the
 * text and returns it.
 *
 * If the nth character is not a normal printable character with a position in
 * the wordwrapped string, returns -1 (for instance, a soft-hyphen character,
 * or a newline character, may not have a corresponding position).
 */ 2 4 this 3 955  1 n 1 853  
246 0 0 6 332 853 0 0 299 /**
 * Computes the character index of the character at the rth row and cth column
 * position.  This is the inverse of calc_r_c().
 *
 * It is legal for c to exceed the index number of the last column by 1, and
 * it is legal for r to exceed the index number of the last row by 1, if c is
 * 0.
 */ 3 4 this 3 955  1 r 1 853  1 c 1 853  
247 0 0 6 333 853 0 0 73 /**
 * Returns the number of characters of text, before wordwrapping.
 */ 1 4 this 3 955  
248 0 0 6 334 959 0 0 182 /**
 * Returns the character at the indicated position in the pre-wordwrapped
 * string.  If the object at this position is a graphic object instead of a
 * character, returns 0.
 */ 2 4 this 3 955  1 n 1 853  
249 0 0 6 334 959 0 0 173 /**
 * Returns the character at the indicated position in the indicated row.  If
 * the object at this position is a graphic object instead of a character,
 * returns 0.
 */ 3 4 this 3 955  1 r 1 853  1 c 1 853  
250 0 0 6 335 949 0 0 190 /**
 * Returns the graphic object at the indicated position in the pre-wordwrapped
 * string.  If the object at this position is a character instead of a graphic
 * object, returns NULL.
 */ 2 4 this 3 955  1 n 1 853  
251 0 0 6 335 949 0 0 180 /**
 * Returns the graphic object at the indicated position in the indicated row.
 * If the object at this position is a character instead of a graphic object,
 * returns NULL.
 */ 3 4 this 3 955  1 r 1 853  1 c 1 853  
252 0 0 6 336 857 0 0 115 /**
 * Returns the width of the character or object at the indicated position in
 * the pre-wordwrapped string.
 */ 2 4 this 3 955  1 n 1 853  
253 0 0 6 336 857 0 0 106 /**
 * Returns the width of the character or object at the indicated position in
 * the indicated row.
 */ 3 4 this 3 955  1 r 1 853  1 c 1 853  
254 0 0 6 337 853 0 0 97 /**
 * Returns the number of rows of text after it has all been wordwrapped and
 * assembled.
 */ 1 4 this 3 955  
255 0 0 6 338 853 0 0 82 /**
 * Returns the number of characters and/or graphic objects in the nth row.
 */ 2 4 this 3 955  1 r 1 853  
256 0 0 6 339 857 0 0 297 /**
 * Returns the x position of the origin of the character or graphic object at
 * the indicated position in the indicated row.
 *
 * It is legal for c to exceed the index number of the last column by 1, and
 * it is legal for r to exceed the index number of the last row by 1, if c is
 * 0.
 */ 3 4 this 3 955  1 r 1 853  1 c 1 853  
257 0 0 6 340 857 0 0 230 /**
 * Returns the y position of the origin of all of the characters or graphic
 * objects in the indicated row.
 *
 * It is legal for r to exceed the index number of the last row by 1.  The
 * value of c is presently ignored.
 */ 3 4 this 3 955  1 r 1 853  1 c 1 853  
258 0 0 7 341 934 0 0 247 /**
 * Actually assembles all of the text into a GeomNode, and returns the node
 * (or possibly a parent of the node, to keep the shadow separate).  Once this
 * has been called, you may query the extents of the text via get_ul(),
 * get_lr().
 */ 1 4 this 3 957  
259 0 0 6 342 960 0 0 91 /**
 * Returns the upper-left corner of the assembled text, in 2-d text
 * coordinates.
 */ 1 4 this 3 955  
260 0 0 6 343 960 0 0 92 /**
 * Returns the lower-right corner of the assembled text, in 2-d text
 * coordinates.
 */ 1 4 this 3 955  
261 0 0 6 344 857 0 0 59 /**
 * Returns the width of a single TextGraphic image.
 */ 2 7 graphic 1 949  10 properties 1 937  
262 0 0 6 344 857 0 0 274 /**
 * Returns the width of a single character, according to its associated font.
 * This also correctly calculates the width of cheesy ligatures and accented
 * characters, which may not exist in the font as such.
 *
 * This does not take kerning into account, however.
 */ 2 9 character 1 959  10 properties 1 937  
263 0 0 6 345 862 0 0 634 /**
 * Returns true if the named character exists in the font exactly as named,
 * false otherwise.  Note that because Panda can assemble glyphs together
 * automatically using cheesy accent marks, this is not a reliable indicator
 * of whether a suitable glyph can be rendered for the character.  For that,
 * use has_character() instead.
 *
 * This returns true for whitespace and Unicode whitespace characters (if they
 * exist in the font), but returns false for characters that would render with
 * the "invalid glyph".  It also returns false for characters that would be
 * synthesized within Panda, but see has_character().
 */ 2 9 character 1 959  10 properties 1 937  
264 0 0 6 346 862 0 0 405 /**
 * Returns true if the named character exists in the font or can be
 * synthesized by Panda, false otherwise.  (Panda can synthesize some accented
 * characters by combining similar-looking glyphs from the font.)
 *
 * This returns true for whitespace and Unicode whitespace characters (if they
 * exist in the font), but returns false for characters that would render with
 * the "invalid glyph".
 */ 2 9 character 1 959  10 properties 1 937  
265 0 0 6 347 862 0 0 695 /**
 * Returns true if the indicated character represents whitespace in the font,
 * or false if anything visible will be rendered for it.
 *
 * This returns true for whitespace and Unicode whitespace characters (if they
 * exist in the font), and returns false for any other characters, including
 * characters that do not exist in the font (these would be rendered with the
 * "invalid glyph", which is visible).
 *
 * Note that this function can be reliably used to identify Unicode whitespace
 * characters only if the font has all of the whitespace characters defined.
 * It will return false for any character not in the font, even if it is an
 * official Unicode whitespace character.
 */ 2 9 character 1 959  10 properties 1 937  
266 0 0 7 365 962 697 0 10 /**
 *
 */ 1 4 name 1 931  
267 0 0 7 365 962 697 0 123 /**
 * It's sort of a copy constructor: it copies the indicated TextProperties,
 * without copying a complete TextNode.
 */ 2 4 name 1 931  4 copy 1 937  
268 0 0 6 368 857 0 0 234 /**
 * Returns the number of units high each line of text is.  This is based on
 * the font.  Note that it is possible for the text to include nested font
 * change commands, in which case the value of this method is questionable.
 */ 1 4 this 3 963  
269 0 0 4 369 915 0 0 183 /**
 * Sets the maximum number of rows that may be formatted by the TextNode.  If
 * more text than this is attempted, it will be truncated and has_overflow()
 * will return true.
 */ 2 4 this 3 962  8 max_rows 1 853  
270 0 0 4 370 915 0 0 96 /**
 * Resets the TextNode's default behavior of not limiting the number of rows
 * of text.
 */ 1 4 this 3 962  
271 0 0 6 371 862 0 0 117 /**
 * Returns true if a limit on the height of the TextNode has been set via
 * set_max_rows(), false otherwise.
 */ 1 4 this 3 963  
272 0 0 6 372 853 0 0 90 /**
 * Returns the limit on the height of the TextNode specified by
 * set_max_rows().
 */ 1 4 this 3 963  
273 0 0 6 373 862 0 0 122 /**
 * Returns true if the last text set on the text node exceeded the max_rows
 * constraint, or false if it all fit.
 */ 1 4 this 3 963  
274 0 0 4 374 915 0 0 10 /**
 *
 */ 2 4 this 3 962  11 frame_color 1 932  
275 0 0 4 374 915 0 0 10 /**
 *
 */ 5 4 this 3 962  1 r 1 857  1 g 1 857  1 b 1 857  1 a 1 857  
276 0 0 7 375 938 0 0 10 /**
 *
 */ 1 4 this 3 963  
277 0 0 4 376 915 0 0 10 /**
 *
 */ 3 4 this 3 962  4 size 1 857  10 uv_portion 1 857  
278 0 0 4 377 915 0 0 10 /**
 *
 */ 1 4 this 3 962  
279 0 0 6 378 857 0 0 10 /**
 *
 */ 1 4 this 3 963  
280 0 0 6 379 857 0 0 10 /**
 *
 */ 1 4 this 3 963  
281 0 0 6 380 862 0 0 10 /**
 *
 */ 1 4 this 3 963  
282 0 0 4 381 915 0 0 10 /**
 *
 */ 2 4 this 3 962  10 card_color 1 932  
283 0 0 4 381 915 0 0 10 /**
 *
 */ 5 4 this 3 962  1 r 1 857  1 g 1 857  1 b 1 857  1 a 1 857  
284 0 0 7 382 938 0 0 10 /**
 *
 */ 1 4 this 3 963  
285 0 0 4 383 915 0 0 10 /**
 *
 */ 2 4 this 3 962  12 card_texture 1 903  
286 0 0 4 384 915 0 0 10 /**
 *
 */ 1 4 this 3 962  
287 0 0 6 385 862 0 0 10 /**
 *
 */ 1 4 this 3 963  
288 0 0 7 386 903 0 0 10 /**
 *
 */ 1 4 this 3 963  
289 0 0 4 387 915 0 0 249 /**
 * Specifies that a border will be drawn around the text when it is next
 * created.  The parameters are the amount of additional padding to insert
 * between the frame and the text in each dimension, and all should generally
 * be positive.
 */ 5 4 this 3 962  4 left 1 857  5 right 1 857  6 bottom 1 857  3 top 1 857  
290 0 0 4 388 915 0 0 308 /**
 * Similar to set_frame_as_margin, except the frame is specified in actual
 * coordinate units (relative to the text's origin), irrespective of the size
 * of the text.  The left and bottom coordinates should generally be negative,
 * while the right and top coordinates should generally be positive.
 */ 5 4 this 3 962  4 left 1 857  5 right 1 857  6 bottom 1 857  3 top 1 857  
291 0 0 4 389 915 0 0 69 /**
 * Specifies that a border will not be drawn around the text.
 */ 1 4 this 3 962  
292 0 0 6 390 862 0 0 10 /**
 *
 */ 1 4 this 3 963  
293 0 0 6 391 862 0 0 368 /**
 * If this is true, the frame was set via a call to set_frame_as_margin(), and
 * the dimension of the frame as returned by get_frame_as_set() represent a
 * margin all around the text.  If false, then the frame was set via a call to
 * set_frame_actual(), and the dimensions of the frame as returned by
 * get_frame_as_set() are relative to the text's origin.
 */ 1 4 this 3 963  
294 0 0 7 392 909 0 0 255 /**
 * Returns the dimensions of the frame as set by set_frame_as_margin() or
 * set_frame_actual().  Use is_frame_actual() to determine how to interpret
 * the values returned by this function.  It is an error to call this if
 * has_frame() is false.
 */ 1 4 this 3 963  
295 0 0 7 393 909 0 0 431 /**
 * Returns the actual dimensions of the frame around the text.  If the frame
 * was set via set_frame_as_margin(), the result returned by this function
 * reflects the size of the current text; if the frame was set via
 * set_frame_actual(), this returns the values actually set.
 *
 * If the text has no frame at all, this returns the dimensions of the text
 * itself, as if the frame were set with a margin of 0, 0, 0, 0.
 */ 1 4 this 3 963  
296 0 0 4 394 915 0 0 84 /**
 * Specifies the thickness of the lines that will be used to draw the frame.
 */ 2 4 this 3 962  10 line_width 1 857  
297 0 0 6 395 857 0 0 82 /**
 * Returns the thickness of the lines that will be used to draw the frame.
 */ 1 4 this 3 963  
298 0 0 4 396 915 0 0 209 /**
 * Enables or disables the drawing of corners for the frame.  These are extra
 * points drawn at each of the four corners, to soften the ugly edges
 * generated when the line width is greater than one.
 */ 2 4 this 3 962  7 corners 1 862  
299 0 0 6 397 862 0 0 10 /**
 *
 */ 1 4 this 3 963  
300 0 0 4 398 915 0 0 294 /**
 * Specifies that a (possibly opaque or semitransparent) card will be held
 * behind the text when it is next created.  Like set_frame_as_margin, the
 * parameters are the amount of additional padding to insert around the text
 * in each dimension, and all should generally be positive.
 */ 5 4 this 3 962  4 left 1 857  5 right 1 857  6 bottom 1 857  3 top 1 857  
301 0 0 4 399 915 0 0 306 /**
 * Similar to set_card_as_margin, except the card is specified in actual
 * coordinate units (relative to the text's origin), irrespective of the size
 * of the text.  The left and bottom coordinates should generally be negative,
 * while the right and top coordinates should generally be positive.
 */ 5 4 this 3 962  4 left 1 857  5 right 1 857  6 bottom 1 857  3 top 1 857  
302 0 0 4 400 915 0 0 197 /**
 * Sets the card_decal flag.  When this is true, the text is decalled onto the
 * card, which is necessary if the TextNode is to be rendered in the 3-d world
 * without putting it in a bin.
 */ 2 4 this 3 962  10 card_decal 1 862  
303 0 0 4 401 915 0 0 67 /**
 * Specifies that a card will not be drawn behind the text.
 */ 1 4 this 3 962  
304 0 0 6 402 862 0 0 10 /**
 *
 */ 1 4 this 3 963  
305 0 0 6 403 862 0 0 62 /**
 * Returns the card_decal flag.  See set_card_decal().
 */ 1 4 this 3 963  
306 0 0 6 404 862 0 0 360 /**
 * If this is true, the card was set via a call to set_card_as_margin(), and
 * the dimension of the card as returned by get_card_as_set() represent a
 * margin all around the text.  If false, then the card was set via a call to
 * set_card_actual(), and the dimensions of the card as returned by
 * get_card_as_set() are relative to the text's origin.
 */ 1 4 this 3 963  
307 0 0 7 405 909 0 0 250 /**
 * Returns the dimensions of the card as set by set_card_as_margin() or
 * set_card_actual().  Use is_card_actual() to determine how to interpret the
 * values returned by this function.  It is an error to call this if
 * has_card() is false.
 */ 1 4 this 3 963  
308 0 0 7 406 909 0 0 424 /**
 * Returns the actual dimensions of the card around the text.  If the card was
 * set via set_card_as_margin(), the result returned by this function reflects
 * the size of the current text; if the card was set via set_card_actual(),
 * this returns the values actually set.
 *
 * If the text has no card at all, this returns the dimensions of the text
 * itself, as if the card were set with a margin of 0, 0, 0, 0.
 */ 1 4 this 3 963  
309 0 0 7 407 909 0 0 251 /**
 * Returns the actual card dimensions, transformed by the matrix set by
 * set_transform().  This returns the card dimensions in actual coordinates as
 * seen by the rest of the world.  Also see get_upper_left_3d() and
 * get_lower_right_3d().
 */ 1 4 this 3 963  
310 0 0 4 408 915 0 0 85 /**
 * Sets an additional transform that is applied to the entire text paragraph.
 */ 2 4 this 3 962  9 transform 1 965  
311 0 0 7 409 967 0 0 10 /**
 *
 */ 1 4 this 3 963  
312 0 0 4 410 915 0 0 79 /**
 * Specifies the coordinate system in which the text will be generated.
 */ 2 4 this 3 962  2 cs 1 906  
313 0 0 6 411 906 0 0 10 /**
 *
 */ 1 4 this 3 963  
314 0 0 4 412 915 0 0 278 /**
 * Specifies the UsageHint that will be applied to generated geometry.  The
 * default is UH_static, which is probably the right setting, but if you know
 * the TextNode's geometry will have a short lifespan, it may be better to set
 * it to UH_stream.  See geomEnums.h.
 */ 2 4 this 3 962  10 usage_hint 1 896  
315 0 0 6 413 896 0 0 102 /**
 * Returns the UsageHint that will be applied to generated geometry.  See
 * set_usage_hint().
 */ 1 4 this 3 963  
316 0 0 4 414 915 0 0 1534 /**
 * Sets the flatten flags.  This should be a union of the
 * TextNode::FlattenFlags options.  This controls the degree of flattening
 * performed on the TextNode's internal geometry (i.e.  the scene graph
 * returned by generate()) each time the text is changed.  In general, more
 * flattening means a more optimal result, but it will take more time to
 * generate.
 *
 * The choice may be any of these three:
 *
 * FF_none - No flatten operation is called.  The letters are left as
 * independent Geoms.
 *
 * FF_light - A flatten_light() operation is called.  The attributes are
 * applied to the vertices, but no nodes are removed.
 *
 * FF_medium - A flatten_medium() operation is called.  The attributes are
 * applied to the vertices, and a few trivial nodes are removed.
 *
 * FF_strong - A flatten_strong() operation is called.  The attributes are
 * applied to the vertices, and the resulting nodes are aggressively combined
 * into as few nodes as possible.
 *
 * In addition to the above choices, you may optionally include the following
 * flag:
 *
 * FF_dynamic_merge - Copy the geoms into a single GeomVertexData as we go,
 * instead of relying on the flatten operation at the end.  This pre-flattens
 * the text considerably, and may obviate the need for flatten altogether; it
 * also tends to improve performance considerably even if you do call flatten.
 * However, it is not as fast as not calling flatten at all.
 *
 * The default is taken from the text-flatten and text-dynamic-merge config
 * variables.
 */ 2 4 this 3 962  13 flatten_flags 1 853  
317 0 0 6 415 853 0 0 63 /**
 * Returns the flatten flags.  See set_flatten_flags().
 */ 1 4 this 3 963  
318 0 0 4 416 915 0 0 160 /**
 * Sets the font that will be used when making text.  If this is set to NULL,
 * the default font will be used, which can be set via set_default_font().
 */ 2 4 this 3 962  4 font 1 885  
319 0 0 4 417 915 0 0 47 /**
 * Resets the font to the default font.
 */ 1 4 this 3 962  
320 0 0 4 418 915 0 0 707 /**
 * Sets the small_caps flag.  When this is set, lowercase letters are
 * generated as scaled-down versions of their uppercase equivalents.  This is
 * particularly useful to set for fonts that do not have lowercase letters.
 *
 * It is also a good idea to set this for a (dynamic) font that has already
 * implemented lowercase letters as scaled-down versions of their uppercase
 * equivalents, since without this flag the texture memory may needlessly
 * duplicate equivalent glyphs for upper and lowercase letters.  Setting this
 * flag causes the texture memory to share the mixed-case letters.
 *
 * The amount by which the lowercase letters are scaled is specified by
 * set_small_caps_scale().
 */ 2 4 this 3 962  10 small_caps 1 862  
321 0 0 4 419 915 0 0 10 /**
 *
 */ 1 4 this 3 962  
322 0 0 4 420 915 0 0 210 /**
 * Sets the scale factor applied to lowercase letters from their uppercase
 * equivalents, when the small_caps flag is in effect.  See set_small_caps().
 * Normally, this will be a number less than one.
 */ 2 4 this 3 962  16 small_caps_scale 1 857  
323 0 0 4 421 915 0 0 10 /**
 *
 */ 1 4 this 3 962  
324 0 0 4 422 915 0 0 10 /**
 *
 */ 2 4 this 3 962  5 slant 1 857  
325 0 0 4 423 915 0 0 10 /**
 *
 */ 1 4 this 3 962  
326 0 0 4 424 915 0 0 10 /**
 *
 */ 2 4 this 3 962  10 align_type 1 883  
327 0 0 4 425 915 0 0 10 /**
 *
 */ 1 4 this 3 962  
328 0 0 4 426 915 0 0 149 /**
 * Specifies the amount of extra space that is inserted before the first
 * character of each line.  This can be thought of as a left margin.
 */ 2 4 this 3 962  6 indent 1 857  
329 0 0 4 427 915 0 0 10 /**
 *
 */ 1 4 this 3 962  
330 0 0 4 428 915 0 0 152 /**
 * Sets the text up to automatically wordwrap when it exceeds the indicated
 * width.  This can be thought of as a right margin or margin width.
 */ 2 4 this 3 962  8 wordwrap 1 857  
331 0 0 4 429 915 0 0 93 /**
 * Removes the wordwrap setting from the TextNode.  Text will be as wide as it
 * is.
 */ 1 4 this 3 962  
332 0 0 4 430 915 0 0 10 /**
 *
 */ 2 4 this 3 962  10 text_color 1 932  
333 0 0 4 430 915 0 0 10 /**
 *
 */ 5 4 this 3 962  1 r 1 857  1 g 1 857  1 b 1 857  1 a 1 857  
334 0 0 4 431 915 0 0 117 /**
 * Removes the text color specification; the text will be colored whatever it
 * was in the source font file.
 */ 1 4 this 3 962  
335 0 0 4 432 915 0 0 10 /**
 *
 */ 2 4 this 3 962  12 shadow_color 1 932  
336 0 0 4 432 915 0 0 10 /**
 *
 */ 5 4 this 3 962  1 r 1 857  1 g 1 857  1 b 1 857  1 a 1 857  
337 0 0 4 433 915 0 0 10 /**
 *
 */ 1 4 this 3 962  
338 0 0 4 434 915 0 0 151 /**
 * Specifies that the text should be drawn with a shadow, by creating a second
 * copy of the text and offsetting it slightly behind the first.
 */ 2 4 this 3 962  13 shadow_offset 1 939  
339 0 0 4 434 915 0 0 151 /**
 * Specifies that the text should be drawn with a shadow, by creating a second
 * copy of the text and offsetting it slightly behind the first.
 */ 3 4 this 3 962  7 xoffset 1 857  7 yoffset 1 857  
340 0 0 4 435 915 0 0 69 /**
 * Specifies that a shadow will not be drawn behind the text.
 */ 1 4 this 3 962  
341 0 0 4 436 915 0 0 362 /**
 * Names the GeomBin that the TextNode geometry should be assigned to.  If
 * this is set, then a GeomBinTransition will be created to explicitly place
 * each component in the named bin.
 *
 * The draw_order value will also be passed to each GeomBinTransition as
 * appropriate; this is particularly useful if this names a GeomBinFixed, e.g.
 * "fixed".
 */ 2 4 this 3 962  3 bin 1 931  
342 0 0 4 437 915 0 0 158 /**
 * Removes the effect of a previous call to set_bin().  Text will be drawn in
 * whatever bin it would like to be drawn in, with no explicit ordering.
 */ 1 4 this 3 962  
343 0 0 6 438 853 0 0 435 /**
 * Sets the drawing order of text created by the TextMaker.  This is actually
 * the draw order of the card and frame.  The shadow is drawn at
 * _draw_order+1, and the text at _draw_order+2.
 *
 * This affects the sorting order assigned to the arcs as they are created,
 * and also is passed to whatever bin may be assigned via set_bin().
 *
 * The return value is the first unused draw_order number, e.g.  _draw_order +
 * 3.
 */ 2 4 this 3 962  10 draw_order 1 853  
344 0 0 4 439 915 0 0 10 /**
 *
 */ 1 4 this 3 962  
345 0 0 4 440 915 0 0 160 /**
 * Sets the width of each tab stop, in screen units.  A tab character embedded
 * in the text will advance the horizontal position to the next tab stop.
 */ 2 4 this 3 962  9 tab_width 1 857  
346 0 0 4 441 915 0 0 10 /**
 *
 */ 1 4 this 3 962  
347 0 0 4 442 915 0 0 208 /**
 * Specifies the factor by which to scale each letter of the text as it is
 * placed.  This can be used (possibly in conjunction with set_glyph_shift())
 * to implement superscripting or subscripting.
 */ 2 4 this 3 962  11 glyph_scale 1 857  
348 0 0 4 443 915 0 0 10 /**
 *
 */ 1 4 this 3 962  
349 0 0 4 444 915 0 0 206 /**
 * Specifies a vertical amount to shift each letter of the text as it is
 * placed.  This can be used (possibly in conjunction with set_glyph_scale())
 * to implement superscripting or subscripting.
 */ 2 4 this 3 962  11 glyph_shift 1 857  
350 0 0 4 445 915 0 0 10 /**
 *
 */ 1 4 this 3 962  
351 0 0 4 446 915 0 0 138 // These methods are inherited from TextEncoder, but we override here so we
// can flag the TextNode as dirty when they have been changed. 2 4 this 3 962  4 text 1 931  
352 0 0 4 446 915 0 0 285 /**
 * The two-parameter version of set_text() accepts an explicit encoding; the
 * text is immediately decoded and stored as a wide-character string.
 * Subsequent calls to get_text() will return the same text re-encoded using
 * whichever encoding is specified by set_encoding().
 */ 3 4 this 3 962  4 text 1 931  8 encoding 1 968  
353 0 0 4 447 915 0 0 46 /**
 * Removes the text from the TextNode.
 */ 1 4 this 3 962  
354 0 0 4 448 915 0 0 70 /**
 * Appends the indicates string to the end of the stored text.
 */ 2 4 this 3 962  4 text 1 931  
355 0 0 4 449 915 0 0 128 /**
 * Appends a single character to the end of the stored text.  This may be a
 * wide character, up to 16 bits in Unicode.
 */ 2 4 this 3 962  9 character 1 959  
356 0 0 6 450 931 0 0 227 /**
 * Returns a string that represents the contents of the text, as it has been
 * formatted by wordwrap rules.
 *
 * In earlier versions, this did not contain any embedded special characters
 * like \1 or \3; now it does.
 */ 1 4 this 3 963  
357 0 0 6 451 857 0 0 126 /**
 * Returns the width of a line of text of arbitrary characters.  The line
 * should not include the newline character.
 */ 2 4 this 3 963  4 line 1 931  
358 0 0 6 451 857 0 0 178 /**
 * Returns the width of a line of text of arbitrary characters.  The line
 * should not include the newline character or any embedded control characters
 * like \1 or \3.
 */ 2 4 this 3 963  4 line 1 931  
359 0 0 6 451 857 0 0 154 /**
 * Returns the width of a single character of the font, or 0.0 if the
 * character is not known.  This may be a wide character (greater than 255).
 */ 2 4 this 3 963  9 character 1 959  
360 0 0 6 452 862 0 0 634 /**
 * Returns true if the named character exists in the font exactly as named,
 * false otherwise.  Note that because Panda can assemble glyphs together
 * automatically using cheesy accent marks, this is not a reliable indicator
 * of whether a suitable glyph can be rendered for the character.  For that,
 * use has_character() instead.
 *
 * This returns true for whitespace and Unicode whitespace characters (if they
 * exist in the font), but returns false for characters that would render with
 * the "invalid glyph".  It also returns false for characters that would be
 * synthesized within Panda, but see has_character().
 */ 2 4 this 3 963  9 character 1 959  
361 0 0 6 453 862 0 0 405 /**
 * Returns true if the named character exists in the font or can be
 * synthesized by Panda, false otherwise.  (Panda can synthesize some accented
 * characters by combining similar-looking glyphs from the font.)
 *
 * This returns true for whitespace and Unicode whitespace characters (if they
 * exist in the font), but returns false for characters that would render with
 * the "invalid glyph".
 */ 2 4 this 3 963  9 character 1 959  
362 0 0 6 454 862 0 0 695 /**
 * Returns true if the indicated character represents whitespace in the font,
 * or false if anything visible will be rendered for it.
 *
 * This returns true for whitespace and Unicode whitespace characters (if they
 * exist in the font), and returns false for any other characters, including
 * characters that do not exist in the font (these would be rendered with the
 * "invalid glyph", which is visible).
 *
 * Note that this function can be reliably used to identify Unicode whitespace
 * characters only if the font has all of the whitespace characters defined.
 * It will return false for any character not in the font, even if it is an
 * official Unicode whitespace character.
 */ 2 4 this 3 963  9 character 1 959  
363 0 0 4 455 915 0 0 196 /**
 * Changes the text that is displayed under the TextNode, with a wide text.
 * This automatically sets the string reported by get_text() to the 8-bit
 * encoded version of the same string.
 */ 2 4 this 3 962  5 wtext 1 931  
364 0 0 4 456 915 0 0 85 /**
 * Appends the indicates string to the end of the stored wide-character text.
 */ 2 4 this 3 962  4 text 1 931  
365 0 0 6 457 931 0 0 228 /**
 * Returns a wstring that represents the contents of the text, as it has been
 * formatted by wordwrap rules.
 *
 * In earlier versions, this did not contain any embedded special characters
 * like \1 or \3; now it does.
 */ 1 4 this 3 963  
366 0 0 4 458 915 0 0 10 /**
 *
 */ 2 4 this 3 963  3 out 1 916  
367 0 0 4 459 915 0 0 10 /**
 *
 */ 3 4 this 3 963  3 out 1 916  12 indent_level 1 853  
368 0 0 6 460 857 0 0 121 /**
 * Returns the leftmost extent of the text in local 2-d coordinates,
 * unmodified by the set_transform() matrix.
 */ 1 4 this 3 963  
369 0 0 6 461 857 0 0 122 /**
 * Returns the rightmost extent of the text in local 2-d coordinates,
 * unmodified by the set_transform() matrix.
 */ 1 4 this 3 963  
370 0 0 6 462 857 0 0 123 /**
 * Returns the bottommost extent of the text in local 2-d coordinates,
 * unmodified by the set_transform() matrix.
 */ 1 4 this 3 963  
371 0 0 6 463 857 0 0 120 /**
 * Returns the topmost extent of the text in local 2-d coordinates, unmodified
 * by the set_transform() matrix.
 */ 1 4 this 3 963  
372 0 0 6 464 857 0 0 71 /**
 * Returns the net height of the text in local 2-d coordinates.
 */ 1 4 this 3 963  
373 0 0 6 465 857 0 0 70 /**
 * Returns the net width of the text in local 2-d coordinates.
 */ 1 4 this 3 963  
374 0 0 7 466 971 0 0 148 /**
 * Returns the upper-left extent of the text object, after it has been
 * transformed into 3-d space by applying the set_transform() matrix.
 */ 1 4 this 3 963  
375 0 0 7 467 971 0 0 149 /**
 * Returns the lower-right extent of the text object, after it has been
 * transformed into 3-d space by applying the set_transform() matrix.
 */ 1 4 this 3 963  
376 0 0 6 468 853 0 0 153 /**
 * Returns the number of rows of text that were generated.  This counts word-
 * wrapped rows as well as rows generated due to embedded newlines.
 */ 1 4 this 3 963  
377 0 0 7 469 934 0 0 168 /**
 * Generates the text, according to the parameters indicated within the
 * TextNode, and returns a Node that may be parented within the tree to
 * represent it.
 */ 1 4 this 3 962  
378 0 0 4 470 915 0 0 193 /**
 * Can be called after the TextNode has been fully configured, to force the
 * node to recompute its text immediately, rather than waiting for it to be
 * drawn.  This call is optional.
 */ 1 4 this 3 962  
379 0 0 4 471 915 0 0 267 /**
 * Forces the TextNode to recompute itself now, even if it believes nothing
 * has changed.  Normally, this should not need to be called, but it may be
 * useful if some properties change outside of the TextNode's knowledge (for
 * instance, within the font).
 */ 1 4 this 3 962  
380 0 0 7 472 934 0 0 331 /**
 * Returns the actual node that is used internally to render the text, if the
 * TextNode is parented within the scene graph.
 *
 * In general, you should not call this method.  Call generate() instead if
 * you want to get a handle to geometry that represents the text.  This method
 * is provided as a debugging aid only.
 */ 1 4 this 3 963  
381 0 0 7 554 912 0 0 0 0 
382 0 0 7 358 934 0 0 0 1 4 this 3 962  
383 0 0 7 359 962 697 0 0 1 4 this 3 934  
384 0 0 6 361 958 0 0 0 1 4 this 3 962  
385 0 0 7 362 962 697 0 0 1 4 this 3 958  
386 0 0 6 363 936 0 0 0 1 4 this 3 962  
387 0 0 7 364 962 697 0 0 1 4 this 3 936  
388 0 0 6 488 931 0 0 0 1 4 this 3 963  
389 0 0 7 490 885 447 0 110 /**
 * Returns the font currently in use, if any.  If no font is in use, this
 * returns the default font.
 */ 1 4 this 3 963  
390 0 0 6 491 862 0 0 10 /**
 *
 */ 1 4 this 3 963  
391 0 0 6 493 862 0 0 62 /**
 * Returns the small_caps flag.  See set_small_caps().
 */ 1 4 this 3 963  
392 0 0 6 494 862 0 0 10 /**
 *
 */ 1 4 this 3 963  
393 0 0 6 496 857 0 0 193 /**
 * Returns the scale factor applied to lowercase letters from their uppercase
 * equivalents, when the small_caps flag is in effect.  See set_small_caps()
 * and set_small_caps_scale().
 */ 1 4 this 3 963  
394 0 0 6 497 862 0 0 10 /**
 *
 */ 1 4 this 3 963  
395 0 0 6 499 857 0 0 83 /**
 * Returns the factor by which the text is specified to slant to the right.
 */ 1 4 this 3 963  
396 0 0 6 500 862 0 0 10 /**
 *
 */ 1 4 this 3 963  
397 0 0 4 504 915 0 0 169 /**
 * Sets the underscore flag.  When this is set, the text is underscored with a
 * one-pixel line the same color as the text foreground, drawn at the
 * baseline.
 */ 2 4 this 3 962  10 underscore 1 862  
398 0 0 6 502 862 0 0 62 /**
 * Returns the underscore flag.  See set_underscore().
 */ 1 4 this 3 963  
399 0 0 6 503 862 0 0 10 /**
 *
 */ 1 4 this 3 963  
400 0 0 4 505 915 0 0 10 /**
 *
 */ 1 4 this 3 962  
401 0 0 4 509 915 0 0 176 /**
 * Specifies the vertical height of the underscore, relative to the text
 * baseline.  This only has meaning if the underscore mode is enabled with
 * set_underscore().
 */ 2 4 this 3 962  17 underscore_height 1 857  
402 0 0 6 507 857 0 0 86 /**
 * Returns the vertical height of the underscore; see set_underscore_height().
 */ 1 4 this 3 963  
403 0 0 6 508 862 0 0 10 /**
 *
 */ 1 4 this 3 963  
404 0 0 4 510 915 0 0 10 /**
 *
 */ 1 4 this 3 962  
405 0 0 6 512 883 0 0 10 /**
 *
 */ 1 4 this 3 963  
406 0 0 6 513 862 0 0 10 /**
 *
 */ 1 4 this 3 963  
407 0 0 6 515 857 0 0 10 /**
 *
 */ 1 4 this 3 963  
408 0 0 6 516 862 0 0 10 /**
 *
 */ 1 4 this 3 963  
409 0 0 6 518 857 0 0 10 /**
 *
 */ 1 4 this 3 963  
410 0 0 6 519 862 0 0 10 /**
 *
 */ 1 4 this 3 963  
411 0 0 4 523 915 0 0 344 /**
 * Sets the preserve_trailing_whitespace flag.  When this is set, trailing
 * whitespace at the end of the line is not stripped when the text is
 * wordwrapped (it is stripped by default).  Since the trailing whitespace is
 * invisible, this is important primarily for determining the proper width of
 * a frame or card behind the text.
 */ 2 4 this 3 962  28 preserve_trailing_whitespace 1 862  
412 0 0 6 521 862 0 0 101 /**
 * Returns the preserve_trailing_whitespace flag.  See
 * set_preserve_trailing_whitespace().
 */ 1 4 this 3 963  
413 0 0 6 522 862 0 0 10 /**
 *
 */ 1 4 this 3 963  
414 0 0 4 524 915 0 0 10 /**
 *
 */ 1 4 this 3 962  
415 0 0 7 526 938 0 0 10 /**
 *
 */ 1 4 this 3 963  
416 0 0 6 527 862 0 0 10 /**
 *
 */ 1 4 this 3 963  
417 0 0 7 529 938 0 0 10 /**
 *
 */ 1 4 this 3 963  
418 0 0 6 530 862 0 0 10 /**
 *
 */ 1 4 this 3 963  
419 0 0 7 532 943 0 0 125 /**
 * Returns the offset of the shadow as set by set_shadow().  It is an error to
 * call this if has_shadow() is false.
 */ 1 4 this 3 963  
420 0 0 6 533 862 0 0 10 /**
 *
 */ 1 4 this 3 963  
421 0 0 6 535 931 0 0 97 /**
 * Returns the drawing bin set with set_bin(), or empty string if no bin has
 * been set.
 */ 1 4 this 3 963  
422 0 0 6 536 862 0 0 98 /**
 * Returns true if an explicit drawing bin has been set via set_bin(), false
 * otherwise.
 */ 1 4 this 3 963  
423 0 0 6 538 853 0 0 63 /**
 * Returns the drawing order set with set_draw_order().
 */ 1 4 this 3 963  
424 0 0 6 539 862 0 0 10 /**
 *
 */ 1 4 this 3 963  
425 0 0 6 541 857 0 0 53 /**
 * Returns the width set via set_tab_width().
 */ 1 4 this 3 963  
426 0 0 6 542 862 0 0 10 /**
 *
 */ 1 4 this 3 963  
427 0 0 6 544 857 0 0 85 /**
 * Returns the scale factor of each letter as specified by set_glyph_scale().
 */ 1 4 this 3 963  
428 0 0 6 545 862 0 0 10 /**
 *
 */ 1 4 this 3 963  
429 0 0 6 547 857 0 0 90 /**
 * Returns the vertical shift of each letter as specified by
 * set_glyph_shift().
 */ 1 4 this 3 963  
430 0 0 6 548 862 0 0 10 /**
 *
 */ 1 4 this 3 963  
431 0 0 4 552 915 0 0 284 /**
 * Specifies the factor by which to scale the text, in addition to any
 * scalings imposed by the node, as well as in addition to the glyph scale.
 *
 * The text scale is not cumulative when applied to nested TextProperties.
 * See also set_glyph_scale(), which is cumulative.
 */ 2 4 this 3 962  10 text_scale 1 857  
432 0 0 6 550 857 0 0 81 /**
 * Returns the scale factor of the text as specified by set_text_scale().
 */ 1 4 this 3 963  
433 0 0 6 551 862 0 0 10 /**
 *
 */ 1 4 this 3 963  
434 0 0 4 553 915 0 0 10 /**
 *
 */ 1 4 this 3 962  
121
851 9 TextGlyph 0 75777 9 TextGlyph 9 TextGlyph 0 0 0 0 0 3 972 973 974 8 435 436 437 438 439 440 441 442 0 0 1 0 852 0 0 0 0 127
/**
 * A representation of a single glyph (character) from a font.  This is a
 * piece of renderable geometry of some kind.
 */

852 19 TypedReferenceCount 0 2049 19 TypedReferenceCount 19 TypedReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 410
/**
 * A base class for things which need to inherit from both TypedObject and
 * from ReferenceCount.  It's convenient to define this intermediate base
 * class instead of multiply inheriting from the two classes each time they
 * are needed, so that we can sensibly pass around pointers to things which
 * are both TypedObjects and ReferenceCounters.
 *
 * See also TypedObject for detailed instructions.
 */

853 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0

854 19 RenderState const * 0 8576 19 RenderState const * 19 RenderState const * 0 0 855 0 0 0 0 0 0 0 0 0 0

855 17 RenderState const 0 8832 17 RenderState const 17 RenderState const 0 0 856 0 0 0 0 0 0 0 0 0 0

856 11 RenderState 0 2048 11 RenderState 11 RenderState 0 0 0 0 0 0 0 0 0 0 0 0 340
/**
 * This represents a unique collection of RenderAttrib objects that correspond
 * to a particular renderable state.
 *
 * You should not attempt to create or modify a RenderState object directly.
 * Instead, call one of the make() functions to create one for you.  And
 * instead of modifying a RenderState object, create a new one.
 */

857 11 PN_stdfloat 0 2105344 11 PN_stdfloat 11 PN_stdfloat 0 0 858 0 0 0 0 0 0 0 0 0 0

858 5 float 0 8194 5 float 5 float 0 2 0 0 0 0 0 0 0 0 0 0 0

859 8 TextFont 0 26625 8 TextFont 8 TextFont 0 0 0 0 447 3 975 976 977 10 448 449 451 452 453 454 455 456 457 458 0 1 450 2 3 852 443 444 3 860 445 446 0 1 861 252
/**
 * An encapsulation of a font; i.e.  a set of glyphs that may be assembled
 * together by a TextNode to represent a string of text.
 *
 * This is just an abstract interface; see StaticTextFont or DynamicTextFont
 * for an actual implementation.
 */

860 7 Namable 0 2049 7 Namable 7 Namable 0 0 0 0 0 0 0 0 0 0 0 0 125
/**
 * A base class for all things which can have a name.  The name is either
 * empty or nonempty, but it is never NULL.
 */

861 10 RenderMode 0 794624 20 TextFont::RenderMode 20 TextFont::RenderMode 859 0 0 0 0 0 0 0 0 0 7 10 RM_texture 20 TextFont::RM_texture 44
// Each glyph is a single textured rectangle
0 12 RM_wireframe 22 TextFont::RM_wireframe 39
// Each glyph is a lot of line segments
1 10 RM_polygon 20 TextFont::RM_polygon 35
// Each glyph is a lot of triangles
2 11 RM_extruded 21 TextFont::RM_extruded 38
// a 3-D outline, like a cookie cutter
3 8 RM_solid 18 TextFont::RM_solid 44
// combination of RM_extruded and RM_polygon
4 17 RM_distance_field 27 TextFont::RM_distance_field 0
5 10 RM_invalid 20 TextFont::RM_invalid 57
// Returned by string_render_mode() for an invalid match.
6 0 0

862 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0

863 16 DynamicTextGlyph 0 75777 16 DynamicTextGlyph 16 DynamicTextGlyph 0 0 0 0 0 1 978 11 459 467 468 469 470 471 472 473 474 475 476 0 0 1 0 851 0 0 0 0 188
/**
 * A specialization on TextGlyph that is generated and stored by a
 * DynamicTextFont.  This keeps some additional information, such as where the
 * glyph appears on a texture map.
 */

864 17 DynamicTextPage * 0 8576 17 DynamicTextPage * 17 DynamicTextPage * 0 0 865 0 0 0 0 0 0 0 0 0 0

865 15 DynamicTextPage 0 141313 15 DynamicTextPage 15 DynamicTextPage 0 0 0 1 465 466 0 5 460 461 462 463 464 0 0 1 0 866 0 0 0 0 197
/**
 * A single "page" of a DynamicTextFont.  This is a single texture that holds
 * a number of glyphs for rendering.  The font starts out with one page, and
 * will add more as it needs them.
 */

866 7 Texture 0 2049 7 Texture 7 Texture 0 0 0 0 0 0 0 0 0 0 0 0 688
/**
 * Represents a texture object, which is typically a single 2-d image but may
 * also represent a 1-d or 3-d texture image, or the six 2-d faces of a cube
 * map texture.
 *
 * A texture's image data might be stored in system RAM (see get_ram_image())
 * or its image may be represented in texture memory on one or more
 * GraphicsStateGuardians (see prepare()), or both.  The typical usage pattern
 * is that a texture is loaded from an image file on disk, which copies its
 * image data into system RAM; then the first time the texture is rendered its
 * image data is copied to texture memory (actually, to the graphics API), and
 * the system RAM image is automatically freed.
 */

867 15 DynamicTextFont 0 26625 15 DynamicTextFont 15 DynamicTextFont 0 0 0 1 481 482 16 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 44 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 1 1053 0 2 3 859 477 478 3 868 479 480 0 0 231
/**
 * A DynamicTextFont is a special TextFont object that rasterizes its glyphs
 * from a standard font file (e.g.  a TTF file) on the fly.  It requires the
 * FreeType 2.0 library (or any higher, backward-compatible version).
 */

868 12 FreetypeFont 0 2049 12 FreetypeFont 12 FreetypeFont 0 0 0 0 0 0 0 0 0 0 0 0 247
/**
 * This is a common base class for both DynamicTextFont and PNMTextMaker.
 * Both of these are utility classes that use the FreeType library to generate
 * glyphs from fonts; this class abstracts out that common wrapper around
 * FreeType.
 */

869 16 LVecBase2i const 0 8832 16 LVecBase2i const 16 LVecBase2i const 0 0 870 0 0 0 0 0 0 0 0 0 0

870 10 LVecBase2i 0 2048 10 LVecBase2i 10 LVecBase2i 0 0 0 0 0 0 0 0 0 0 0 0 75
/**
 * This is the base class for all two-component vectors and points.
 */

871 10 FilterType 0 794624 24 SamplerState::FilterType 24 SamplerState::FilterType 872 0 0 0 0 0 0 0 0 0 9 10 FT_nearest 24 SamplerState::FT_nearest 25
// Point sample the pixel
0 9 FT_linear 23 SamplerState::FT_linear 48
// Bilinear filtering of four neighboring pixels
1 25 FT_nearest_mipmap_nearest 39 SamplerState::FT_nearest_mipmap_nearest 55
// Point sample the pixel from the nearest mipmap level
2 24 FT_linear_mipmap_nearest 38 SamplerState::FT_linear_mipmap_nearest 58
// Bilinear filter the pixel from the nearest mipmap level
3 24 FT_nearest_mipmap_linear 38 SamplerState::FT_nearest_mipmap_linear 68
// Point sample the pixel from two mipmap levels, and linearly blend
4 23 FT_linear_mipmap_linear 37 SamplerState::FT_linear_mipmap_linear 116
// A.k.a.  trilinear filtering: Bilinear filter the pixel from two mipmap
// levels, and linearly blend the results.
5 9 FT_shadow 23 SamplerState::FT_shadow 79
// The OpenGL ARB_shadow extension can be thought of as a kind of
// filtering.
6 10 FT_default 24 SamplerState::FT_default 129
// Default is usually linear, but it depends on format.  This was added at
// the end of the list to avoid bumping TXO version #.
7 10 FT_invalid 24 SamplerState::FT_invalid 57
// Returned by string_filter_type() for an invalid match.
8 0 0

872 12 SamplerState 0 2048 12 SamplerState 12 SamplerState 0 0 0 0 0 0 0 0 0 0 0 0 176
/**
 * Represents a set of settings that indicate how a texture is sampled.  This
 * can be used to sample the same texture using different settings in
 * different places.
 */

873 12 LColor const 0 8832 12 LColor const 12 LColor const 0 0 874 0 0 0 0 0 0 0 0 0 0

874 6 LColor 0 2105344 6 LColor 6 LColor 0 0 875 0 0 0 0 0 0 0 0 0 0

875 7 LColorf 0 2105344 7 LColorf 7 LColorf 0 0 876 0 0 0 0 0 0 0 0 0 0

876 10 LVecBase4f 0 2048 10 LVecBase4f 10 LVecBase4f 0 0 0 0 0 0 0 0 0 0 0 0 77
/**
 * This is the base class for all three-component vectors and points.
 */

877 6 Format 0 794624 15 Texture::Format 15 Texture::Format 866 0 0 0 0 0 0 0 0 0 46 15 F_depth_stencil 24 Texture::F_depth_stencil 0
1 13 F_color_index 22 Texture::F_color_index 0
2 5 F_red 14 Texture::F_red 0
3 7 F_green 16 Texture::F_green 0
4 6 F_blue 15 Texture::F_blue 0
5 7 F_alpha 16 Texture::F_alpha 0
6 5 F_rgb 14 Texture::F_rgb 55
// any suitable RGB mode, whatever the hardware prefers
7 6 F_rgb5 15 Texture::F_rgb5 27
// 5 bits per R,G,B channel
8 6 F_rgb8 15 Texture::F_rgb8 27
// 8 bits per R,G,B channel
9 7 F_rgb12 16 Texture::F_rgb12 28
// 12 bits per R,G,B channel
10 8 F_rgb332 17 Texture::F_rgb332 33
// 3 bits per R & G, 2 bits for B
11 6 F_rgba 15 Texture::F_rgba 56
// any suitable RGBA mode, whatever the hardware prefers
12 6 F_rgbm 15 Texture::F_rgbm 58
// as above, but only requires 1 bit for alpha (i.e. mask)
13 7 F_rgba4 16 Texture::F_rgba4 29
// 4 bits per R,G,B,A channel
14 7 F_rgba5 16 Texture::F_rgba5 40
// 5 bits per R,G,B channel, 1 bit alpha
15 7 F_rgba8 16 Texture::F_rgba8 29
// 8 bits per R,G,B,A channel
16 8 F_rgba12 17 Texture::F_rgba12 30
// 12 bits per R,G,B,A channel
17 11 F_luminance 20 Texture::F_luminance 0
18 17 F_luminance_alpha 26 Texture::F_luminance_alpha 33
// 8 bits luminance, 8 bits alpha
19 21 F_luminance_alphamask 30 Texture::F_luminance_alphamask 46
// 8 bits luminance, only needs 1 bit of alpha
20 8 F_rgba16 17 Texture::F_rgba16 30
// 16 bits per R,G,B,A channel
21 8 F_rgba32 17 Texture::F_rgba32 30
// 32 bits per R,G,B,A channel
22 17 F_depth_component 26 Texture::F_depth_component 0
23 19 F_depth_component16 28 Texture::F_depth_component16 0
24 19 F_depth_component24 28 Texture::F_depth_component24 0
25 19 F_depth_component32 28 Texture::F_depth_component32 0
26 5 F_r16 14 Texture::F_r16 0
27 6 F_rg16 15 Texture::F_rg16 0
28 7 F_rgb16 16 Texture::F_rgb16 0
29 6 F_srgb 15 Texture::F_srgb 101
// These formats are in the sRGB color space.  RGB is 2.2 gamma corrected,
// alpha is always linear.
30 12 F_srgb_alpha 21 Texture::F_srgb_alpha 0
31 12 F_sluminance 21 Texture::F_sluminance 0
32 18 F_sluminance_alpha 27 Texture::F_sluminance_alpha 0
33 6 F_r32i 15 Texture::F_r32i 41
// 32-bit integer, used for atomic access
34 5 F_r32 14 Texture::F_r32 0
35 6 F_rg32 15 Texture::F_rg32 0
36 7 F_rgb32 16 Texture::F_rgb32 0
37 5 F_r8i 14 Texture::F_r8i 31
// 8 integer bits per R channel
38 6 F_rg8i 15 Texture::F_rg8i 33
// 8 integer bits per R,G channel
39 7 F_rgb8i 16 Texture::F_rgb8i 35
// 8 integer bits per R,G,B channel
40 8 F_rgba8i 17 Texture::F_rgba8i 37
// 8 integer bits per R,G,B,A channel
41 13 F_r11_g11_b10 22 Texture::F_r11_g11_b10 58
// unsigned floating-point, 11 Red, 11 Green, 10 Blue Bits
42 9 F_rgb9_e5 18 Texture::F_rgb9_e5 0
43 10 F_rgb10_a2 19 Texture::F_rgb10_a2 0
44 4 F_rg 13 Texture::F_rg 0
45 6 F_r16i 15 Texture::F_r16i 0
46 0 0

878 8 FontPool 0 141313 8 FontPool 8 FontPool 0 0 0 0 536 0 9 527 528 529 530 531 532 533 534 535 0 0 0 0 0 186
/**
 * This is the preferred interface for loading fonts for the TextNode system.
 * It is similar to ModelPool and TexturePool in that it unifies references to
 * the same filename.
 */

879 13 GeomTextGlyph 0 75777 13 GeomTextGlyph 13 GeomTextGlyph 0 0 0 0 0 0 1 537 0 0 1 0 880 0 0 0 0 292
/**
 * This is a specialization on Geom for containing a primitive intended to
 * represent a TextGlyph.  Its sole purpose is to maintain the geom count on
 * the glyph, so we can determine the actual usage count on a dynamic glyph
 * (and thus know when it is safe to recycle the glyph).
 */

880 4 Geom 0 2049 4 Geom 4 Geom 0 0 0 0 0 0 0 0 0 0 0 0 418
/**
 * A container for geometry primitives.  This class associates one or more
 * GeomPrimitive objects with a table of vertices defined by a GeomVertexData
 * object.  All of the primitives stored in a particular Geom are drawn from
 * the same set of vertices (each primitive uses a subset of all of the
 * vertices in the table), and all of them must be rendered at the same time,
 * in the same graphics state.
 */

881 14 StaticTextFont 0 141313 14 StaticTextFont 14 StaticTextFont 0 0 0 1 538 540 0 1 539 0 0 1 0 859 0 0 0 0 251
/**
 * A StaticTextFont is loaded up from a model that was previously generated
 * via egg-mkfont, and contains all of its glyphs already generated and
 * available for use.  It doesn't require linking with any external libraries
 * like FreeType.
 */

882 14 TextProperties 0 141313 14 TextProperties 14 TextProperties 0 0 0 1 541 632 20 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 90 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 0 0 0 0 2 883 884 822
/**
 * This defines the set of visual properties that may be assigned to the
 * individual characters of the text.  (Properties which affect the overall
 * block of text can only be specified on the TextNode directly).
 *
 * Typically, there is just one set of properties on a given block of text,
 * which is set directly on the TextNode (TextNode inherits from
 * TextProperties). That makes all of the text within a particular block have
 * the same appearance.
 *
 * This separate class exists in order to implement multiple different kinds
 * of text appearing within one block.  The text string itself may reference a
 * TextProperties structure by name using the \1 and \2 tokens embedded within
 * the string; each nested TextProperties structure modifies the appearance of
 * subsequent text within the block.
 */

883 9 Alignment 0 794624 25 TextProperties::Alignment 25 TextProperties::Alignment 882 0 0 0 0 0 0 0 0 0 6 6 A_left 22 TextProperties::A_left 0
0 7 A_right 23 TextProperties::A_right 0
1 8 A_center 24 TextProperties::A_center 0
2 12 A_boxed_left 28 TextProperties::A_boxed_left 0
3 13 A_boxed_right 29 TextProperties::A_boxed_right 0
4 14 A_boxed_center 30 TextProperties::A_boxed_center 0
5 0 0

884 9 Direction 0 794624 25 TextProperties::Direction 25 TextProperties::Direction 882 0 0 0 0 0 0 0 0 0 2 5 D_ltr 21 TextProperties::D_ltr 0
0 5 D_rtl 21 TextProperties::D_rtl 0
1 0 0

885 10 TextFont * 0 8576 10 TextFont * 10 TextFont * 0 0 859 0 0 0 0 0 0 0 0 0 0

886 8 LVector2 0 2105344 8 LVector2 8 LVector2 0 0 887 0 0 0 0 0 0 0 0 0 0

887 9 LVector2f 0 2048 9 LVector2f 9 LVector2f 0 0 0 0 0 0 0 0 0 0 0 0 49
/**
 * This is a two-component vector offset.
 */

888 12 string const 0 8832 17 std::string const 17 std::string const 0 0 889 0 0 0 0 0 0 0 0 0 0

889 6 string 0 2105344 11 std::string 11 std::string 0 0 890 0 0 0 0 0 0 0 0 0 0

890 20 basic_string< char > 0 2048 25 std::basic_string< char > 25 std::basic_string< char > 0 0 0 0 0 0 0 0 0 0 0 0 0

891 11 TextGraphic 0 141313 11 TextGraphic 11 TextGraphic 0 0 0 1 633 640 3 1015 1016 1017 6 634 635 636 637 638 639 0 0 0 0 0 761
/**
 * This defines a special model that has been constructed for the purposes of
 * embedding an arbitrary graphic image within a text paragraph.
 *
 * It can be any arbitrary model, though it should be built along the same
 * scale as the text, and it should probably be at least mostly two-
 * dimensional.  Typically, this means it should be constructed in the X-Z
 * plane, and it should have a maximum vertical (Z) height of 1.0.
 *
 * The frame specifies an arbitrary bounding volume in the form (left, right,
 * bottom, top).  This indicates the amount of space that will be reserved
 * within the paragraph.  The actual model is not actually required to fit
 * within this rectangle, but if it does not, it may visually overlap with
 * nearby text.
 */

892 8 NodePath 0 2048 8 NodePath 8 NodePath 0 0 0 0 0 0 0 0 0 0 0 0 762
/**
 * NodePath is the fundamental system for disambiguating instances, and also
 * provides a higher-level interface for manipulating the scene graph.
 *
 * A NodePath is a list of connected nodes from the root of the graph to any
 * sub-node.  Each NodePath therefore uniquely describes one instance of a
 * node.
 *
 * NodePaths themselves are lightweight objects that may easily be copied and
 * passed by value.  Their data is stored as a series of NodePathComponents
 * that are stored on the nodes.  Holding a NodePath will keep a reference
 * count to all the nodes in the path.  However, if any node in the path is
 * removed or reparented (perhaps through a different NodePath), the NodePath
 * will automatically be updated to reflect the changes.
 */

893 9 LVecBase4 0 2105344 9 LVecBase4 9 LVecBase4 0 0 876 0 0 0 0 0 0 0 0 0 0

894 21 TextPropertiesManager 0 43009 21 TextPropertiesManager 21 TextPropertiesManager 0 0 0 0 0 0 10 641 642 643 644 645 646 647 648 649 650 0 0 0 0 0 1100
/**
 * This defines all of the TextProperties structures that might be referenced
 * by name from an embedded text string.
 *
 * A text string, as rendered by a TextNode, can contain embedded references
 * to one of the TextProperties defined here, by enclosing the name between \1
 * (ASCII 0x01) characters; this causes a "push" to the named state.  All text
 * following the closing \1 character will then be rendered in the new state.
 * The next \2 (ASCII 0x02) character will then restore the previous state for
 * subsequent text.
 *
 * For instance, "x\1up\1n\2 + y" indicates that the character "x" will be
 * rendered in the normal state, the character "n" will be rendered in the
 * "up" state, and then " + y" will be rendered in the normal state again.
 *
 * This can also be used to define arbitrary models that can serve as embedded
 * graphic images in a text paragraph.  This works similarly; the convention
 * is to create a TextGraphic that describes the graphic image, and then
 * associate it here via the set_graphic() call.  Then "\5name\5" will embed
 * the named graphic.
 */

895 13 TextAssembler 0 26625 13 TextAssembler 13 TextAssembler 0 0 0 1 651 653 5 1018 1019 1020 1021 1022 37 652 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 0 0 0 0 0 290
/**
 * This class is not normally used directly by user code, but is used by the
 * TextNode to lay out a block of text and convert it into rows of Geoms
 * according to the TextProperties.  However, user code may take advantage of
 * it, if desired, for very low-level text operations.
 */

896 9 UsageHint 0 794624 20 GeomEnums::UsageHint 20 GeomEnums::UsageHint 897 0 0 0 0 0 0 0 0 0 5 9 UH_client 20 GeomEnums::UH_client 80
// UH_client: don't attempt to upload the data; always keep it on the
// client.
0 9 UH_stream 20 GeomEnums::UH_stream 154
// UH_stream: the data will be created once, used to render a few times,
// and then discarded.  This should be used for short-lived temporary
// objects.
1 10 UH_dynamic 21 GeomEnums::UH_dynamic 170
// UH_dynamic: the data will be repeatedly modified and re-rendered.  This
// is for data that will be modified at runtime, such as animated or soft-
// skinned vertices.
2 9 UH_static 20 GeomEnums::UH_static 281
// UH_static: the data will be created once, and used to render many
// times, without modification.  This is the most common case, since
// typically vertex data is not directly animated (this is not related to
// scene graph animation, e.g.  from adjusting transforms on a node).
3 14 UH_unspecified 25 GeomEnums::UH_unspecified 265
// UH_unspecified: the usage is unspecified.  This is intended as a "don't
// care" option for abstract objects; it should not be applied to any
// actual geometry to be rendered.  You take your chances if a geom
// actually gets into the scene graph with this set.
4 0 0

897 9 GeomEnums 0 2048 9 GeomEnums 9 GeomEnums 0 0 0 0 0 0 0 0 0 0 0 0 184
/**
 * This class exists just to provide scoping for the various enumerated types
 * used by Geom, GeomVertexData, GeomVertexArrayData, GeomPrimitive, and other
 * related classes.
 */

898 20 TextProperties const 0 8832 20 TextProperties const 20 TextProperties const 0 0 882 0 0 0 0 0 0 0 0 0 0

899 8 TextNode 0 26625 8 TextNode 8 TextNode 0 0 0 1 696 697 30 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 106 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 850 0 0 3 3 900 690 691 3 901 692 693 3 882 694 695 0 1 902 917
/**
 * The primary interface to this module.  This class does basic text assembly;
 * given a string of text and a TextFont object, it creates a piece of
 * geometry that may be placed in the 3-d or 2-d world to represent the
 * indicated text.
 *
 * The TextNode may be used in one of two ways.  Naively, it may simply be
 * parented directly into the scene graph and rendered as if it were a
 * GeomNode; in this mode, the actual polygon geometry that renders the text
 * is not directly visible or accessible, but remains hidden within the
 * TextNode.
 *
 * The second way TextNode may be used is as a text generator.  To use it in
 * this way, do not parent the TextNode to the scene graph; instead, set the
 * properties of the text and call generate() to return an ordinary node,
 * containing ordinary geometry, which you may use however you like.  Each
 * time you call generate() a new node is returned.
 */

900 9 PandaNode 0 2049 9 PandaNode 9 PandaNode 0 0 0 0 0 0 0 0 0 0 0 0 175
/**
 * A basic node of the scene graph or data graph.  This is the base class of
 * all specialized nodes, and also serves as a generic node with no special
 * properties.
 */

901 11 TextEncoder 0 2049 11 TextEncoder 11 TextEncoder 0 0 0 0 0 0 0 0 0 0 0 0 400
/**
 * This class can be used to convert text between multiple representations,
 * e.g.  utf-8 to Unicode.  You may use it as a static class object, passing
 * the encoding each time, or you may create an instance and use that object,
 * which will record the current encoding and retain the current string.
 *
 * This class is also a base class of TextNode, which inherits this
 * functionality.
 */

902 12 FlattenFlags 0 794624 22 TextNode::FlattenFlags 22 TextNode::FlattenFlags 899 0 0 0 0 0 0 0 0 0 5 7 FF_none 17 TextNode::FF_none 0
0 8 FF_light 18 TextNode::FF_light 0
1 9 FF_medium 19 TextNode::FF_medium 0
2 9 FF_strong 19 TextNode::FF_strong 0
4 16 FF_dynamic_merge 26 TextNode::FF_dynamic_merge 0
8 0 0

903 9 Texture * 0 8576 9 Texture * 9 Texture * 0 0 866 0 0 0 0 0 0 0 0 0 0

904 8 LMatrix4 0 2105344 8 LMatrix4 8 LMatrix4 0 0 905 0 0 0 0 0 0 0 0 0 0

905 9 LMatrix4f 0 2048 9 LMatrix4f 9 LMatrix4f 0 0 0 0 0 0 0 0 0 0 0 0 45
/**
 * This is a 4-by-4 transform matrix.
 */

906 16 CoordinateSystem 0 532480 16 CoordinateSystem 16 CoordinateSystem 0 0 0 0 0 0 0 0 0 0 6 10 CS_default 10 CS_default 210
// The CS_default entry does not refer to a particular coordinate system,
// but rather to the value stored in default_coordinate_system, which in
// turn is loaded from the config variable "coordinate-system".
0 12 CS_zup_right 12 CS_zup_right 0
1 12 CS_yup_right 12 CS_yup_right 0
2 11 CS_zup_left 11 CS_zup_left 0
3 11 CS_yup_left 11 CS_yup_left 0
4 10 CS_invalid 10 CS_invalid 156
// CS_invalid is not a coordinate system at all.  It can be used in user-
// input processing code to indicate a contradictory coordinate system
// request.
5 0 0

907 17 TextGlyph const * 0 8576 17 TextGlyph const * 17 TextGlyph const * 0 0 908 0 0 0 0 0 0 0 0 0 0

908 15 TextGlyph const 0 8832 15 TextGlyph const 15 TextGlyph const 0 0 851 0 0 0 0 0 0 0 0 0 0

909 11 LVecBase4 * 0 8576 11 LVecBase4 * 11 LVecBase4 * 0 0 893 0 0 0 0 0 0 0 0 0 0

910 6 Geom * 0 8576 6 Geom * 6 Geom * 0 0 880 0 0 0 0 0 0 0 0 0 0

911 10 TypeHandle 0 2048 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732
/**
 * TypeHandle is the identifier used to differentiate C++ class types.  Any
 * C++ classes that inherit from some base class, and must be differentiated
 * at run time, should store a static TypeHandle object that can be queried
 * through a static member function named get_class_type().  Most of the time,
 * it is also desirable to inherit from TypedObject, which provides some
 * virtual functions to return the TypeHandle for a particular instance.
 *
 * At its essence, a TypeHandle is simply a unique identifier that is assigned
 * by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so
 * that ancestry of a particular type may be queried, and the type name may be
 * retrieved for run-time display.
 */

912 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 911 0 0 0 0 0 0 0 0 0 0

913 16 TextFont const * 0 8576 16 TextFont const * 16 TextFont const * 0 0 914 0 0 0 0 0 0 0 0 0 0

914 14 TextFont const 0 8832 14 TextFont const 14 TextFont const 0 0 859 0 0 0 0 0 0 0 0 0 0

915 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0

916 9 ostream * 0 8576 9 ostream * 9 ostream * 0 0 917 0 0 0 0 0 0 0 0 0 0

917 7 ostream 0 2048 7 ostream 7 ostream 0 0 0 0 0 0 0 0 0 0 0 0 0

918 21 TypedReferenceCount * 0 8576 21 TypedReferenceCount * 21 TypedReferenceCount * 0 0 852 0 0 0 0 0 0 0 0 0 0

919 9 Namable * 0 8576 9 Namable * 9 Namable * 0 0 860 0 0 0 0 0 0 0 0 0 0

920 24 DynamicTextGlyph const * 0 8576 24 DynamicTextGlyph const * 24 DynamicTextGlyph const * 0 0 921 0 0 0 0 0 0 0 0 0 0

921 22 DynamicTextGlyph const 0 8832 22 DynamicTextGlyph const 22 DynamicTextGlyph const 0 0 863 0 0 0 0 0 0 0 0 0 0

922 23 DynamicTextPage const * 0 8576 23 DynamicTextPage const * 23 DynamicTextPage const * 0 0 923 0 0 0 0 0 0 0 0 0 0

923 21 DynamicTextPage const 0 8832 21 DynamicTextPage const 21 DynamicTextPage const 0 0 865 0 0 0 0 0 0 0 0 0 0

924 18 LVecBase2i const * 0 8576 18 LVecBase2i const * 18 LVecBase2i const * 0 0 869 0 0 0 0 0 0 0 0 0 0

925 23 DynamicTextFont const * 0 8576 23 DynamicTextFont const * 23 DynamicTextFont const * 0 0 926 0 0 0 0 0 0 0 0 0 0

926 21 DynamicTextFont const 0 8832 21 DynamicTextFont const 21 DynamicTextFont const 0 0 867 0 0 0 0 0 0 0 0 0 0

927 17 DynamicTextFont * 0 8576 17 DynamicTextFont * 17 DynamicTextFont * 0 0 867 0 0 0 0 0 0 0 0 0 0

928 16 Filename const * 0 8576 16 Filename const * 16 Filename const * 0 0 929 0 0 0 0 0 0 0 0 0 0

929 14 Filename const 0 8832 14 Filename const 14 Filename const 0 0 930 0 0 0 0 0 0 0 0 0 0

930 8 Filename 0 2048 8 Filename 8 Filename 0 0 0 0 0 0 0 0 0 0 0 0 550
/**
 * The name of a file, such as a texture file or an Egg file.  Stores the full
 * pathname, and includes functions for extracting out the directory prefix
 * part and the file extension and stuff.
 *
 * A Filename is also aware of the mapping between the Unix-like filename
 * convention we use internally, and the local OS's specific filename
 * convention, and it knows how to perform basic OS-specific I/O, like testing
 * for file existence and searching a searchpath, as well as the best way to
 * open an fstream for reading or writing.
 */

931 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0

932 14 LColor const * 0 8576 14 LColor const * 14 LColor const * 0 0 873 0 0 0 0 0 0 0 0 0 0

933 14 FreetypeFont * 0 8576 14 FreetypeFont * 14 FreetypeFont * 0 0 868 0 0 0 0 0 0 0 0 0 0

934 11 PandaNode * 0 8576 11 PandaNode * 11 PandaNode * 0 0 900 0 0 0 0 0 0 0 0 0 0

935 16 StaticTextFont * 0 8576 16 StaticTextFont * 16 StaticTextFont * 0 0 881 0 0 0 0 0 0 0 0 0 0

936 16 TextProperties * 0 8576 16 TextProperties * 16 TextProperties * 0 0 882 0 0 0 0 0 0 0 0 0 0

937 22 TextProperties const * 0 8576 22 TextProperties const * 22 TextProperties const * 0 0 898 0 0 0 0 0 0 0 0 0 0

938 8 LColor * 0 8576 8 LColor * 8 LColor * 0 0 874 0 0 0 0 0 0 0 0 0 0

939 17 LVecBase2 const * 0 8576 17 LVecBase2 const * 17 LVecBase2 const * 0 0 940 0 0 0 0 0 0 0 0 0 0

940 15 LVecBase2 const 0 8832 15 LVecBase2 const 15 LVecBase2 const 0 0 941 0 0 0 0 0 0 0 0 0 0

941 9 LVecBase2 0 2105344 9 LVecBase2 9 LVecBase2 0 0 942 0 0 0 0 0 0 0 0 0 0

942 10 LVecBase2f 0 2048 10 LVecBase2f 10 LVecBase2f 0 0 0 0 0 0 0 0 0 0 0 0 75
/**
 * This is the base class for all two-component vectors and points.
 */

943 10 LVector2 * 0 8576 10 LVector2 * 10 LVector2 * 0 0 886 0 0 0 0 0 0 0 0 0 0

944 13 TextGraphic * 0 8576 13 TextGraphic * 13 TextGraphic * 0 0 891 0 0 0 0 0 0 0 0 0 0

945 16 NodePath const * 0 8576 16 NodePath const * 16 NodePath const * 0 0 946 0 0 0 0 0 0 0 0 0 0

946 14 NodePath const 0 8832 14 NodePath const 14 NodePath const 0 0 892 0 0 0 0 0 0 0 0 0 0

947 17 LVecBase4 const * 0 8576 17 LVecBase4 const * 17 LVecBase4 const * 0 0 948 0 0 0 0 0 0 0 0 0 0

948 15 LVecBase4 const 0 8832 15 LVecBase4 const 15 LVecBase4 const 0 0 893 0 0 0 0 0 0 0 0 0 0

949 19 TextGraphic const * 0 8576 19 TextGraphic const * 19 TextGraphic const * 0 0 950 0 0 0 0 0 0 0 0 0 0

950 17 TextGraphic const 0 8832 17 TextGraphic const 17 TextGraphic const 0 0 891 0 0 0 0 0 0 0 0 0 0

951 10 NodePath * 0 8576 10 NodePath * 10 NodePath * 0 0 892 0 0 0 0 0 0 0 0 0 0

952 23 TextPropertiesManager * 0 8576 23 TextPropertiesManager * 23 TextPropertiesManager * 0 0 894 0 0 0 0 0 0 0 0 0 0

953 29 TextPropertiesManager const * 0 8576 29 TextPropertiesManager const * 29 TextPropertiesManager const * 0 0 954 0 0 0 0 0 0 0 0 0 0

954 27 TextPropertiesManager const 0 8832 27 TextPropertiesManager const 27 TextPropertiesManager const 0 0 894 0 0 0 0 0 0 0 0 0 0

955 21 TextAssembler const * 0 8576 21 TextAssembler const * 21 TextAssembler const * 0 0 956 0 0 0 0 0 0 0 0 0 0

956 19 TextAssembler const 0 8832 19 TextAssembler const 19 TextAssembler const 0 0 895 0 0 0 0 0 0 0 0 0 0

957 15 TextAssembler * 0 8576 15 TextAssembler * 15 TextAssembler * 0 0 895 0 0 0 0 0 0 0 0 0 0

958 13 TextEncoder * 0 8576 13 TextEncoder * 13 TextEncoder * 0 0 901 0 0 0 0 0 0 0 0 0 0

959 7 wchar_t 0 8194 7 wchar_t 7 wchar_t 0 1 0 0 0 0 0 0 0 0 0 0 0

960 16 LVector2 const * 0 8576 16 LVector2 const * 16 LVector2 const * 0 0 961 0 0 0 0 0 0 0 0 0 0

961 14 LVector2 const 0 8832 14 LVector2 const 14 LVector2 const 0 0 886 0 0 0 0 0 0 0 0 0 0

962 10 TextNode * 0 8576 10 TextNode * 10 TextNode * 0 0 899 0 0 0 0 0 0 0 0 0 0

963 16 TextNode const * 0 8576 16 TextNode const * 16 TextNode const * 0 0 964 0 0 0 0 0 0 0 0 0 0

964 14 TextNode const 0 8832 14 TextNode const 14 TextNode const 0 0 899 0 0 0 0 0 0 0 0 0 0

965 16 LMatrix4 const * 0 8576 16 LMatrix4 const * 16 LMatrix4 const * 0 0 966 0 0 0 0 0 0 0 0 0 0

966 14 LMatrix4 const 0 8832 14 LMatrix4 const 14 LMatrix4 const 0 0 904 0 0 0 0 0 0 0 0 0 0

967 10 LMatrix4 * 0 8576 10 LMatrix4 * 10 LMatrix4 * 0 0 904 0 0 0 0 0 0 0 0 0 0

968 8 Encoding 0 794624 21 TextEncoder::Encoding 21 TextEncoder::Encoding 901 0 0 0 0 0 0 0 0 0 3 9 E_iso8859 22 TextEncoder::E_iso8859 0
0 6 E_utf8 19 TextEncoder::E_utf8 0
1 9 E_unicode 22 TextEncoder::E_unicode 0
2 0 0

969 7 LPoint3 0 2105344 7 LPoint3 7 LPoint3 0 0 970 0 0 0 0 0 0 0 0 0 0

970 8 LPoint3f 0 2048 8 LPoint3f 8 LPoint3f 0 0 0 0 0 0 0 0 0 0 0 0 337
/**
 * This is a three-component point in space (as opposed to a three-component
 * vector, which represents a direction and a distance).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

971 9 LPoint3 * 0 8576 9 LPoint3 * 9 LPoint3 * 0 0 969 0 0 0 0 0 0 0 0 0 0

0
81
972 9 character 0 2 853 435 0 0 0 0 0 20 TextGlyph::character 0

973 5 state 0 2 854 438 0 0 0 0 0 16 TextGlyph::state 0

974 7 advance 0 2 857 439 0 0 0 0 0 18 TextGlyph::advance 0

975 5 valid 0 2 862 449 0 0 0 0 0 15 TextFont::valid 0

976 11 line_height 0 6 857 451 452 0 0 0 0 21 TextFont::line_height 0

977 13 space_advance 0 6 857 453 454 0 0 0 0 23 TextFont::space_advance 0

978 4 page 0 2 864 459 0 0 0 0 0 22 DynamicTextGlyph::page 0

979 10 point_size 0 6 857 486 485 0 0 0 0 27 DynamicTextFont::point_size 0

980 15 pixels_per_unit 0 6 857 488 487 0 0 0 0 32 DynamicTextFont::pixels_per_unit 0

981 12 scale_factor 0 6 857 490 489 0 0 0 0 29 DynamicTextFont::scale_factor 0

982 16 native_antialias 0 6 862 492 491 0 0 0 0 33 DynamicTextFont::native_antialias 0

983 15 font_pixel_size 0 2 853 493 0 0 0 0 0 32 DynamicTextFont::font_pixel_size 0

984 14 texture_margin 0 6 853 497 496 0 0 0 0 31 DynamicTextFont::texture_margin 0

985 11 poly_margin 0 6 857 499 498 0 0 0 0 28 DynamicTextFont::poly_margin 0

986 9 page_size 0 6 869 501 500 0 0 0 0 26 DynamicTextFont::page_size 0

987 9 minfilter 0 6 871 505 504 0 0 0 0 26 DynamicTextFont::minfilter 0

988 9 magfilter 0 6 871 507 506 0 0 0 0 26 DynamicTextFont::magfilter 0

989 18 anisotropic_degree 0 6 853 509 508 0 0 0 0 35 DynamicTextFont::anisotropic_degree 0

990 11 render_mode 0 6 861 511 510 0 0 0 0 28 DynamicTextFont::render_mode 0

991 2 fg 0 6 873 513 512 0 0 0 0 19 DynamicTextFont::fg 0

992 2 bg 0 6 873 515 514 0 0 0 0 19 DynamicTextFont::bg 0

993 10 tex_format 0 2 877 520 0 0 0 0 0 27 DynamicTextFont::tex_format 0

994 5 pages 0 66 864 522 0 0 0 0 521 22 DynamicTextFont::pages 0

995 4 font 0 30 885 552 549 551 550 0 0 20 TextProperties::font 0

996 10 small_caps 0 30 862 556 553 555 554 0 0 26 TextProperties::small_caps 0

997 16 small_caps_scale 0 30 857 560 557 559 558 0 0 32 TextProperties::small_caps_scale 0

998 5 slant 0 30 857 564 561 563 562 0 0 21 TextProperties::slant 0

999 10 underscore 0 30 862 568 565 567 566 0 0 26 TextProperties::underscore 0

1000 17 underscore_height 0 30 857 572 569 571 570 0 0 33 TextProperties::underscore_height 0

1001 5 align 0 30 883 576 573 575 574 0 0 21 TextProperties::align 0

1002 6 indent 0 30 857 580 577 579 578 0 0 22 TextProperties::indent 0

1003 8 wordwrap 0 30 857 584 581 583 582 0 0 24 TextProperties::wordwrap 0

1004 28 preserve_trailing_whitespace 0 30 862 588 585 587 586 0 0 44 TextProperties::preserve_trailing_whitespace 0

1005 10 text_color 0 30 874 592 589 591 590 0 0 26 TextProperties::text_color 0

1006 12 shadow_color 0 30 874 596 593 595 594 0 0 28 TextProperties::shadow_color 0

1007 6 shadow 0 30 886 600 597 599 598 0 0 22 TextProperties::shadow 0

1008 3 bin 0 30 888 604 601 603 602 0 0 19 TextProperties::bin 0

1009 10 draw_order 0 30 853 608 605 607 606 0 0 26 TextProperties::draw_order 0

1010 9 tab_width 0 30 857 612 609 611 610 0 0 25 TextProperties::tab_width 0

1011 11 glyph_scale 0 30 857 616 613 615 614 0 0 27 TextProperties::glyph_scale 0

1012 11 glyph_shift 0 30 857 620 617 619 618 0 0 27 TextProperties::glyph_shift 0

1013 10 text_scale 0 30 857 624 621 623 622 0 0 26 TextProperties::text_scale 0

1014 9 direction 0 30 884 628 625 627 626 0 0 25 TextProperties::direction 0

1015 5 model 0 6 892 634 635 0 0 0 0 18 TextGraphic::model 0

1016 5 frame 0 6 893 636 637 0 0 0 0 18 TextGraphic::frame 0

1017 13 instance_flag 0 6 862 638 639 0 0 0 0 26 TextGraphic::instance_flag 0

1018 10 usage_hint 0 6 896 656 655 0 0 0 0 25 TextAssembler::usage_hint 0

1019 8 max_rows 0 6 853 658 657 0 0 0 0 23 TextAssembler::max_rows 0

1020 13 dynamic_merge 0 6 862 660 659 0 0 0 0 28 TextAssembler::dynamic_merge 0

1021 14 multiline_mode 0 6 862 662 661 0 0 0 0 29 TextAssembler::multiline_mode 0

1022 10 properties 0 6 898 664 663 0 0 0 0 25 TextAssembler::properties 0

1023 8 max_rows 0 6 853 702 699 0 0 0 0 18 TextNode::max_rows 0

1024 11 frame_color 0 6 874 705 704 0 0 0 0 21 TextNode::frame_color 0

1025 10 card_color 0 6 874 712 711 0 0 0 0 20 TextNode::card_color 0

1026 12 card_texture 0 6 903 716 713 0 0 0 0 22 TextNode::card_texture 0

1027 16 frame_line_width 0 6 857 725 724 0 0 0 0 26 TextNode::frame_line_width 0

1028 13 frame_corners 0 6 862 727 726 0 0 0 0 23 TextNode::frame_corners 0

1029 9 transform 0 6 904 739 738 0 0 0 0 19 TextNode::transform 0

1030 17 coordinate_system 0 6 906 741 740 0 0 0 0 27 TextNode::coordinate_system 0

1031 10 usage_hint 0 6 896 743 742 0 0 0 0 20 TextNode::usage_hint 0

1032 13 flatten_flags 0 6 853 745 744 0 0 0 0 23 TextNode::flatten_flags 0

1033 4 text 0 6 889 803 776 0 0 0 0 14 TextNode::text 0

1034 4 font 0 30 885 804 746 805 747 0 0 14 TextNode::font 0

1035 10 small_caps 0 30 862 806 748 807 749 0 0 20 TextNode::small_caps 0

1036 16 small_caps_scale 0 30 857 808 750 809 751 0 0 26 TextNode::small_caps_scale 0

1037 5 slant 0 30 857 810 752 811 753 0 0 15 TextNode::slant 0

1038 10 underscore 0 30 862 812 814 813 815 0 0 20 TextNode::underscore 0

1039 17 underscore_height 0 30 857 816 818 817 819 0 0 27 TextNode::underscore_height 0

1040 5 align 0 30 883 820 754 821 755 0 0 15 TextNode::align 0

1041 6 indent 0 30 857 822 756 823 757 0 0 16 TextNode::indent 0

1042 8 wordwrap 0 30 857 824 758 825 759 0 0 18 TextNode::wordwrap 0

1043 28 preserve_trailing_whitespace 0 30 862 826 828 827 829 0 0 38 TextNode::preserve_trailing_whitespace 0

1044 10 text_color 0 30 874 830 760 831 761 0 0 20 TextNode::text_color 0

1045 12 shadow_color 0 30 874 832 762 833 763 0 0 22 TextNode::shadow_color 0

1046 6 shadow 0 30 886 834 764 835 765 0 0 16 TextNode::shadow 0

1047 3 bin 0 30 888 836 766 837 767 0 0 13 TextNode::bin 0

1048 10 draw_order 0 30 853 838 768 839 769 0 0 20 TextNode::draw_order 0

1049 9 tab_width 0 30 857 840 770 841 771 0 0 19 TextNode::tab_width 0

1050 11 glyph_scale 0 30 857 842 772 843 773 0 0 21 TextNode::glyph_scale 0

1051 11 glyph_shift 0 30 857 844 774 845 775 0 0 21 TextNode::glyph_shift 0

1052 10 text_scale 0 30 857 846 848 847 849 0 0 20 TextNode::text_scale 0

1
1053 9 get_pages 0 521 522 26 DynamicTextFont::get_pages 0

